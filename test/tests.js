//
//=== TEMP Utilities 'Module' ==================================================
//
// (will be separated out into an actual module when up and working)

/**
 * A dummy data definition encapsulating the piece of data itself, a
 * description, and one or more tags.
 */
class DummyData{
    
    /**
     * @param {string} desc - a description of the piece of data.
     * @param {string[]} tags - zero or more tags to associate with the data.
     * @param {*} val - the actual piece of data.
     * @param {string} [type] - the data's type.
     * @param {string} [tagPath] - the data's tag path.
     */
    constructor(desc, tags, val, type, tagPath){
        if(!(is.string(desc) && is.not.empty(desc))) throw new TypeError('description must be a non-empty string');
        if(!(is.array(tags) && is.all.string(tags))) throw new TypeError('tags must be an array of strings');
        if(is.not.undefined(type) && is.not.string(type)) throw new TypeError('if p, type must be a string');
        this._description = desc;
        this._tags = [...tags];
        this._value = val;
        this._tagLookup = {};
        this._type = type;
        this._tagPath = tagPath;
        for(const t of this._tags){
            this._tagLookup[t] = true;
        }
    }
    
    /*
     * @type {string}
     */
    get description(){
        return this._description;
    }
    
    /**
     * @type {string[]}
     */
    get tags(){
        return this._tags;
    }
    
    /**
     * @type {*}
     */
    get value(){
        return this._value;
    }
    
    /**
     * @type {string|undefined}
     */
    get type(){
        return this._type;
    }
    
    /**
     * @type {string|undefined}
     */
    get tagPath(){
        return this._tagPath;
    }
    
    /**
     * @return {boolean}
     */
    hasTag(t){
        if(is.not.string(t)) throw new TypeError('tag must be a string');
        return this._tagLookup[t] ? true : false;
    }
}

/**
 * A utility 'module' for tests. Will be broken out into a separate project
 * later.
 */
const util = {
    /**
     * The library of dummy data organised by type and period-separated tag
     * path.
     *
     * This data structure is generated by the `.refreshDummyData()` function.
     *
     * @type {Map<string, Map<string, DummyData>>}
     */
    allDummyData: {},
    /**
     * Refresh the dummy data.
     * 
     * @param {...function(): Map<string, Map<string, Array>>} dataGenerators -
     * references to zero or more functions that return additional dummy data
     * beyond the default set. The generators must return a data structure
     * containing three-element arrays indexed by tag path indexed by type. The
     * first element in the arrays must be a textual description of the piece
     * of dummy data, the second a list of additional tags as an array of
     * strings (the tags that make up the tag path should not be included), and
     * the dummy data value. E.g.:
     *
     * ```
     * function muDummyDataGen(){
     *     return {
     *         number: {
     *             'mu.studentNumber': ['a student number', ['integer'], 99999999]
     *         },
     *         string: {
     *             'mu.studentNumber': ['a student number string', ['integer', 'numeric'], '99999999']
     *         }
     *     };
     * }
     * ```
     */
    refreshDummyData: function(...dataGenerators){
        /**
         * The default set of dummy data that will get transformed to form the
         * basis of the `.allDummyData` object.
         *
         * The data structure is organised by type, and then by period-separated
         * tag-path.
         *
         * Each piece of dummy data is represented as a three-value array where
         * the first element is a string descriving the value, the second an
         * array of additional tags, and the third the value itself.
         *
         * The individual parts of the tag path and the additional tags are
         * combined to assemble the tags propert, so don't replicate tags in
         * both places
         *
         * @type {Map<string, Map<string, Array>>}
         * @private
         */
        const rawData = {
            'boolean': {
                'true': ['true', ['basic'], true],
                'false': ['false', ['falsy'], false]
            },
            'number': {
                'zero': ['the number zero', ['integer', 'falsy'], 0],
                'digit': ['a single-digit number', ['integer'], 7],
                'integer': ['a positive integer', ['basic'], 12345],
                'integer.2digit': ['a 2-digit number', [], 42],
                'integer.3digit': ['a 3-digit number', [], 123],
                'integer.4digit': ['a 4-digit number', [], 1982],
                'uts': ['a numeric Unix Time-stamp', ['datetime', 'integer'], 1529660265],
                'integer.negative': ['a negative integer', [], -12345],
                'float': ['a positive floating point number', [], 3.14],
                'float.negative': ['a negative floating point number', [], -3.14]
            },
            'string': {
                'empty': ['an empty string', ['falsy'], ''],
                'word': ['a single-word string', ['basic'], 'boogers'],
                'line': ['a single-line string', [], 'boogers and snot'],
                'multiline': ['a multi-line string', [''], 'boogers\nsnot\nbogeys'],
                'zero': ['the character 0', ['integer', 'numeric'], '0'],
                'digit': ['a single-digit string', ['integer', 'numeric'], '7'],
                'integer': ['a positive integer string', ['numeric'], '12345'],
                'integer.2digit': ['a 2-digit numeric string', ['numeric'], '42'],
                'integer.3digit': ['a 3-digit numeric string', ['numeric'], '123'],
                'integer.4digit': ['a 4-digit numeric string', ['numeric'], '1982'],
                'uts': ['a Unix Time-stamp string', ['datetime', 'numeric', 'integer'], '1529660265'],
                'iso8601': ['an ISO8601 date & time string', ['datetime'], '2018-06-22T09:37:45z'],
                'rfc2822': ['an RFC2822 date & time string', ['datetime'], 'Fri, 22 Jun 2018 09:37:45 +0000'],
                'jsdate': ['a JavaScript date & time string', ['datetime'], '2018-06-22T09:37:45.000Z'],
                'integer.negative': ['a negative integer string', ['numeric'], '-12345'],
                'float': ['a floating point numeric string', ['numeric'], '3.14'],
                'float.negative': ['a negative floating point numeric string', ['numeric'], '-3.14']
            },
            'array': {
                'empty': ['an empty array', ['object'], []],
                'basic': ['an array of primitives', ['object', 'basic'], [true, 42, 'boogers']]
            },
            'object': {
                'null': ['null', ['empty', 'falsy', 'basic'], null],
                'empty': ['empty object', ['plain'], {}],
                'plain': ['a plain object', ['basic'], {a: 'b', c: 42, d: true}],
                'jsdate': ['a date object', ['datetime'], new Date('2018-06-22T09:37:45.000Z')],
                'jsdate.now': ['a date object', ['datetime'], new Date()]
            },
            'function': {
                'void': ['a void function', ['object', 'basic'], function(){}]
            },
            'error': {
                'Error': ['a generic error', ['object', 'basic'], new Error('a generic error')],
                'TypeError': ['a type error', ['object'], new TypeError('a type error')],
                'RangeError': ['a range error', ['object'], new TypeError('a range error')]
            },
            'other': {
                "undefined": ['undefined', ['empty', 'falsy', 'basic'], undefined]
            }
        };
        const ans = {};
        
        // incorporate the default data
        for(const t of Object.keys(rawData)){
            ans[t] = {};
            for(const tp of Object.keys(rawData[t])){
                ans[t][tp] = new DummyData(
                    rawData[t][tp][0],
                    [...tp.split('.'), ...rawData[t][tp][1]],
                    rawData[t][tp][2],
                    t,
                    tp
                );
            }
        }
        
        // incporporate the data from the generator functions (if any)
        for(const genFn of dataGenerators){
            try{
                const extraData = genFn();
                if(is.not.object(extraData)) throw new TypeError('generator did not return an object');
                for(const t of Object.keys(extraData)){
                    if(is.not.object(extraData[t])) throw new TypeError(`generatedData['${t}'] is not an object`);
                    if(is.undefined(ans[t])) ans[t] = {};
                    for(const tp of Object.keys(extraData[t])){
                        if(is.not.array(extraData[t][tp])) throw new TypeError(`generatedData['${t}']['${tp}'] is not an array`);
                        if(is.not.string(extraData[t][tp][0])) throw new TypeError(`generatedData['${t}']['${tp}'][0] is not a string`);
                        if(is.not.array(extraData[t][tp][1]) || !is.all.string(extraData[t][tp][1])) throw new TypeError(`generatedData['${t}']['${tp}'][1] is not an array of strings`);
                        ans[t][tp] = new DummyData(
                            extraData[t][tp][0],
                            [...tp.split('.'), ...extraData[t][tp][1]],
                            extraData[t][tp][2],
                            t,
                            tp
                        );
                    }
                }
            }catch(err){
                throw new Error(`failed to load additional data from genereator function with error: ${err.message}`);
            }
        }
        
        // store the new data set
        this.allDummyData = ans;
    },
    
    /**
     * Returns a single piece of dummy data, or, all the dummy data for a
     * given type, or all the dummy data.
     *
     * To get a single piece of dummy data pass its type and tag path as a
     * single period-separated string, e.g. `'string.word'` for the dummy data
     * with type `string` and tag path `word`, or `'number.integer.negative'`
     * for the dummy data with type `number` and tag path `integer.negative`.
     *
     * To get all the dummy data for a given type pass the type as a string,
     * e.g. `'boolean'` for all dummy boolean data.
     *
     * To get all the dummy data, simply pass `'*'`.
     *
     * When querying all the dummy data both entire sections and specific tags
     * can be excluded, and when querying all the dummy data for a sigle type
     * specific tags can be excluded.
     *
     * @param {string} path - a type, or, a type and tag path as a single
     * period-separated string, or the special value `'*'`.
     * @param {object} [opts] - an optional options object.
     * @param {string[]} [opts.excludeTypes] - a list of types to exclude when
     * requesting all dummy data (`path` is `'*'`).
     * @param {string[]} [opts.excludeTags] - a list of tags to exclude when
     * requesting all dummy data, or the dummy data for a given type.
     * @param {string[]} [opts.excludeDefinitions] - a list of individual data
     * definitions to exclude as period-separated type and tag path strings.
     * @return {DummyData[]|DummyData|undefined} Returns all the dummy data
     * for a given type, or a single piece of dummy data for a type with tag
     * path. If only a type is passed and that type does not exist an empty
     * array is returned, if the path has two or more parts and the type or
     * tag path don't exist, `undefined` is returned.
     * @throws {TypeError}
     */
    dummyData: function(path, opts){
        if(!(is.string(path) && is.not.empty(path))) throw new TypeError('path must be a non-empty string');
        if(is.not.object(opts)) opts = {};
        const pathParts = path.split('.');
        const reqType = pathParts[0];
        
        // if a single piece of data or a single type is requested, and does not exist, return
        if(reqType !== '*'){
            if(is.not.object(this.allDummyData[reqType])) return pathParts.length === 1 ? [] : undefined;
        }
        
        // deal with requests for a single piece of data
        if(pathParts.length > 1) return this.allDummyData[reqType][pathParts.slice(1).join('.')];
        
        // deal with requests for data for one or more types
        
        // figure out what types to process
        const typesToFetch = [];
        if(reqType === '*'){
            const typeSkipLookup = {};
            if(is.array(opts.excludeTypes)){
                for(const t of opts.excludeTypes) typeSkipLookup[t] = true;
            }
            for(const t of Object.keys(this.allDummyData)){
                if(!typeSkipLookup[t]) typesToFetch.push(t);
            }
        }else{
            typesToFetch.push(reqType);
        }
        
        // figure out which individual definitions to skip
        const defSkipLookup = {};
        if(is.array(opts.excludeDefinitions)){
            for(const dp of opts.excludeDefinitions) defSkipLookup[dp] = true;
        }
        
        // process all the requested types
        const ans = [];
        const doCheckTags = is.array(opts.excludeTags);
        for(const t of typesToFetch){
            processTypeDummyData:
            for(const tp of Object.keys(this.allDummyData[t])){
                if(doCheckTags){
                    for(const et of opts.excludeTags){
                        if(this.allDummyData[t][tp].hasTag(et)) continue processTypeDummyData;
                    }
                }
                if(!defSkipLookup[`${t}.${tp}`]) ans.push(this.allDummyData[t][tp]);
            }
        }
        return ans;
    },
    
    /**
     * A function to return all dummy data except those for the given
     * types and those matching the given tags tags.
     *
     * This is a shortcut for:
     * 
     * ```
     * .dummyData(
     *     '*',
     *     {
     *         excludeTypes: arguments[0],
     *         excludeTags: arguments[1],
     *         excludeDefinitions: arguments[2]
     *     }
     * )
     * ```
     *
     * @param {string[]} [excludeTypes]
     * @param {string[]} [excludeTags]
     * @param {string[]} [excludeDefinitions]
     * @return {DummyData[]}
     */
    dummyDataExcept: function(excludeTypes, excludeTags, excludeDefinitions){
        if(is.not.array(excludeTypes)) excludeTypes = [];
        if(is.not.array(excludeTags)) excludeTags = [];
        if(is.not.array(excludeDefinitions)) excludeDefinitions = [];
        return this.dummyData('*', {excludeTypes, excludeTags, excludeDefinitions});
    },
    
    /**
     * A function to return all basic dummy data, i.e. all dummy data tagged
     * `basic`.
     *
     * This is a shortcut for `dummyDataWithAnyTag('basic')`.
     *
     * @return {DummyData[]}
     */
    dummyBasicData: function(){
        return this.dummyDataWithAnyTag('basic');
    },
    
    /**
     * A function to return all basic dummy data that's not an object, i.e. all
     * dummy data tagged `basic` that does not have either the type or tag
     * `object`.
     *
     * @return {DummyData[]}
     */
    dummyBasicPrimitives: function(){
        const ans = [];
        for(const dd of this.dummyBasicData()){
            if(dd.type != 'object' && !dd.hasTag('object')) ans.push(dd);
        }
        return ans;
    },
    
    /**
     * A function to return all basic dummy data except those for zero or more
     * given types.
     *
     * @param {...string} excludeTypes
     * @return {DummyData[]}
     */
    dummyBasicDataExcept: function(...excludeTypes){
        const excludeLookup = {};
        for(const et of excludeTypes) excludeLookup[et] = true;
        const ans = [];
        for(const dd of this.dummyBasicData()){
            if(!excludeLookup[dd.type]){
                ans.push(dd);
            }
        }
        return ans;
    },
    
    /**
     * A function to return all basic dummy primitives except those for zero or
     * more given types.
     *
     * @param {...string} excludeTypes
     * @return {DummyData[]}
     */
    dummyBasicPrimitivesExcept: function(...excludeTypes){
        const excludeLookup = {};
        for(const et of excludeTypes) excludeLookup[et] = true;
        const ans = [];
        for(const dd of this.dummyBasicPrimitives()){
            if(!excludeLookup[dd.type]){
                ans.push(dd);
            }
        }
        return ans;
    },
    
    /**
     * Returns the dummy data of one or more types.
     * 
     * @param {...string} typeList
     * @return {DummyData[]}
     * @throws {TypeError}
     */
    dummyDataByType: function(...typeList){
        if(!is.all.string(typeList)) throw new TypeError('all specified types must be strings');
        const ans = [];
        for(const t of typeList){
            if(is.object(this.allDummyData[t])) ans.push(...Object.values(this.allDummyData[t]));
        }
        return ans;
    },
    
    /**
     * Returns the dummy data matching **any** of the given tags.
     * 
     * @param {...string} tagList
     * @return {DummyData[]}
     * @throws {TypeError}
     */
    dummyDataWithAnyTag: function(...tagList){
        if(!is.all.string(tagList)) throw new TypeError('all specified tags must be strings');
        const ans = [];
        for(const td of Object.values(this.allDummyData)){
            for(const dd of Object.values(td)){
                // test if any requested tag is present
                let anyPresent = false;
                for(const t of tagList){
                    if(dd.hasTag(t)){
                        anyPresent = true;
                        break;
                    }
                }
                if(anyPresent) ans.push(dd);
            }
            
        }
        return ans;
    },
    
    /**
     * Returns the dummy data matching **all** of the given tags.
     * 
     * @param {...string} tagList
     * @return {DummyData[]}
     * @throws {TypeError}
     */
    dummyDataWithAllTags: function(...tagList){
        if(!is.all.string(tagList)) throw new TypeError('all specified tags must be strings');
        const ans = [];
        for(const td of Object.values(this.allDummyData)){
            for(const dd of Object.values(td)){
                // make sure every tag is present
                let allPresent = true;
                for(const t of tagList){
                    if(!dd.hasTag(t)){
                        allPresent = false;
                        break;
                    }
                }
                if(allPresent) ans.push(dd);
            }
        }
        return ans;
    }
};

// initialise the dummy data
util.refreshDummyData();

//
//=== The Tests ================================================================
//

QUnit.module('Static Validation Functions', {}, function(){
    QUnit.test('isDateNumber()', function(a){
        const mustAlwaysReturnFalse = [
            ...util.dummyDataExcept([], ['integer']),
            util.dummyData('number.integer.negative'),
            util.dummyData('string.integer.negative')
            
        ];
        a.expect((mustAlwaysReturnFalse.length * 2) + 5);
        
        // make sure the function actually exists
        a.ok(is.function(MoodleVersion.isDateNumber), 'function exists');
        
        // make sure values that should always return false do so in both modes
        for(const dd of mustAlwaysReturnFalse){
            a.strictEqual(MoodleVersion.isDateNumber(dd.value, false), false, `${dd.description} returns false without strict type checking`);
            a.strictEqual(MoodleVersion.isDateNumber(dd.value, true), false, `${dd.description} returns false with strict type checking`);
        }
        
        // make sure values that are always correct return true in both modes
        a.strictEqual(MoodleVersion.isDateNumber(20180517, false), true, '20180517 returns true without strict type checking');
        a.strictEqual(MoodleVersion.isDateNumber(20180517, true), true, '20180517 returns true with strict type checking');
        
        // make sure valid strings are only accepted when strict mode is disabled
        a.strictEqual(MoodleVersion.isReleaseNumber('20180517', false), true, "'20180517' returns true without strict type checking");
        a.strictEqual(MoodleVersion.isReleaseNumber('20180517', true), false, "'20180517' returns false with strict type checking");
    });
    
    QUnit.test('isBranch()', function(a){
        const mustReturnFalse = [
            ...util.dummyDataExcept(['string'], []),
            util.dummyData('string.word'),
            util.dummyData('string.multiline'),
        ];
        a.expect(mustReturnFalse.length + 4);
        
        // make sure the function actually exists
        a.ok(is.function(MoodleVersion.isBranch), 'function exists');
        
        // make sure values that should return false do
        for(const dd of mustReturnFalse){
            a.strictEqual(MoodleVersion.isBranch(dd.value), false, `${dd.description} returns false`);
        }
        
        // make sure subtly incorrect values return false
        a.strictEqual(MoodleVersion.isBranch('0.1'), false, "'0.1' returns false");
        a.strictEqual(MoodleVersion.isBranch('3.55'), false, "'3.55' returns false");
        
        // make sure valid values return true
        a.strictEqual(MoodleVersion.isBranch('3.5'), true, "'3.5' returns true");
    });
    
    QUnit.test('isBranchNumber()', function(a){
        const mustAlwaysReturnFalse = [
            ...util.dummyDataExcept([], ['2digit'])
        ];
        a.expect((mustAlwaysReturnFalse.length * 2) + 5);
        
        // make sure the function actually exists
        a.ok(is.function(MoodleVersion.isBranchNumber), 'function exists');
        
        // make sure values that should always return false do so in both modes
        for(const dd of mustAlwaysReturnFalse){
            a.strictEqual(MoodleVersion.isBranchNumber(dd.value, false), false, `${dd.description} returns false without strict type checking`);
            a.strictEqual(MoodleVersion.isBranchNumber(dd.value, true), false, `${dd.description} returns false with strict type checking`);
        }
        
        // make sure values that are always correct return true in both modes
        a.strictEqual(MoodleVersion.isBranchNumber(35, false), true, '35 returns true without strict type checking');
        a.strictEqual(MoodleVersion.isBranchNumber(35, true), true, '35 returns true with strict type checking');
        
        // make sure valid strings are only accepted when strict mode is disabled
        a.strictEqual(MoodleVersion.isBranchNumber('35', false), true, "'35' returns true without strict type checking");
        a.strictEqual(MoodleVersion.isBranchNumber('35', true), false, "'35' returns false with strict type checking");
    });
    
    QUnit.test('isReleaseNumber()', function(a){
        const mustAlwaysReturnFalse = [
            ...util.dummyDataExcept([], ['integer'], ['string.empty']),
            util.dummyData('number.integer.negative'),
            util.dummyData('string.integer.negative')
            
        ];
        a.expect((mustAlwaysReturnFalse.length * 2) + 11);
        
        // make sure the function actually exists
        a.ok(is.function(MoodleVersion.isReleaseNumber), 'function exists');
        
        // make sure values that should always return false do so in both modes
        for(const dd of mustAlwaysReturnFalse){
            a.strictEqual(MoodleVersion.isReleaseNumber(dd.value, false), false, `${dd.description} returns false without strict type checking`);
            a.strictEqual(MoodleVersion.isReleaseNumber(dd.value, true), false, `${dd.description} returns false with strict type checking`);
        }
        
        // make sure values that are always correct return true in both modes
        a.strictEqual(MoodleVersion.isReleaseNumber(0, false), true, '0 returns true without strict type checking');
        a.strictEqual(MoodleVersion.isReleaseNumber(0, true), true, '0 returns true with strict type checking');
        a.strictEqual(MoodleVersion.isReleaseNumber(3, false), true, '3 returns true without strict type checking');
        a.strictEqual(MoodleVersion.isReleaseNumber(3, true), true, '3 returns true with strict type checking');
        a.strictEqual(MoodleVersion.isReleaseNumber(33, false), true, '33 returns true without strict type checking');
        a.strictEqual(MoodleVersion.isReleaseNumber(33, true), true, '33 returns true with strict type checking');
        
        // make sure valid strings are only accepted when strict mode is disabled
        a.strictEqual(MoodleVersion.isReleaseNumber('3', false), true, "'3' returns true without strict type checking");
        a.strictEqual(MoodleVersion.isReleaseNumber('3', true), false, "'3' returns false with strict type checking");
        
        // make sure both the digit zero and the empty string are accepted when strict mode is disabled
        a.strictEqual(MoodleVersion.isReleaseNumber('0', false), true, "'0' returns true without strict type checking");
        a.strictEqual(MoodleVersion.isReleaseNumber('', false), true, "the empty string returns true without strict type checking");
    });
    
    QUnit.test('isReleaseType()', function(a){
        const mustReturnFalse = [
            ...util.dummyBasicData()
        ];
        
        a.expect(mustReturnFalse.length + 4);
        
        // make sure the function actually exists
        a.ok(is.function(MoodleVersion.isReleaseType), 'function exists');
        
        // make sure values that should return false do
        for(const dd of mustReturnFalse){
            a.strictEqual(MoodleVersion.isReleaseType(dd.value), false, `${dd.description} returns false`);
        }
        
        // make sure all three valid values return true
        a.strictEqual(MoodleVersion.isReleaseType('development'), true, "'development' returns true");
        a.strictEqual(MoodleVersion.isReleaseType('official'), true, "'official' returns true");
        a.strictEqual(MoodleVersion.isReleaseType('weekly'), true, "'weekly' returns true");
    });
    
    QUnit.test('isReleaseSuffix()', function(a){
        const mustReturnFalse = [
            ...util.dummyBasicData()
        ];
        
        a.expect(mustReturnFalse.length + 4);
        
        // make sure the function actually exists
        a.ok(is.function(MoodleVersion.isReleaseSuffix), 'function exists');
        
        // make sure values that should return false do
        for(const dd of mustReturnFalse){
            a.strictEqual(MoodleVersion.isReleaseSuffix(dd.value), false, `${dd.description} returns false`);
        }
        
        // make sure all three valid values return true
        a.strictEqual(MoodleVersion.isReleaseSuffix('dev'), true, "'dev' returns true");
        a.strictEqual(MoodleVersion.isReleaseSuffix(''), true, 'an empty string returns true');
        a.strictEqual(MoodleVersion.isReleaseSuffix('+'), true, "'+' returns true");
    });
});

QUnit.module('Static Conversion Functions', {}, function(){    
    QUnit.test('branchFromBranchNumber()', function(a){
        const mustReturnUndefined = [
            ...util.dummyDataExcept([], ['2digit'])
        ];
        a.expect(mustReturnUndefined.length + 3);
        
        // make sure the function actually exists
        a.ok(is.function(MoodleVersion.branchFromBranchNumber), 'function exists');
        
        // make sure the data that should return undefined does
        for(const dd of mustReturnUndefined){
            a.ok(is.undefined(MoodleVersion.branchFromBranchNumber(dd.value)), `${dd.description} returns undefined`);
        }
        
        // make sure valid data returns as expected
        a.strictEqual(MoodleVersion.branchFromBranchNumber(35), '3.5', "35 converts to '3.5'");
        a.strictEqual(MoodleVersion.branchFromBranchNumber('35'), '3.5', "'35' converts to '3.5'");
    });
    
    QUnit.test('branchFromBranchingDateNumber()', function(a){
        const mustReturnUndefined = [
            ...util.dummyBasicDataExcept('number')
        ];
        a.expect(mustReturnUndefined.length + 5);
        
        // make sure the function actually exists
        a.ok(is.function(MoodleVersion.branchFromBranchingDateNumber), 'function exists');
        
        // make sure the data that should return undefined does
        for(const dd of mustReturnUndefined){
            a.ok(is.undefined(MoodleVersion.branchFromBranchingDateNumber(dd.value)), `${dd.description} returns undefined`);
        }
        
        // make sure valid data returns as expected
        a.strictEqual(MoodleVersion.branchFromBranchingDateNumber(20180517), '3.5', "20180517 converts to '3.5'");
        a.strictEqual(MoodleVersion.branchFromBranchingDateNumber('20180517'), '3.5', "'20180517' converts to '3.5'");
        a.ok(is.undefined(MoodleVersion.branchFromBranchingDateNumber(20180513)), '20180513 converts to undefined (no such mapping)');
        a.ok(is.undefined(MoodleVersion.branchFromBranchingDateNumber('20180513')),"'20180513' converts to undefined (no such mapping)");
    });
    
    QUnit.test('branchNumberFromBranch()', function(a){
        const mustReturnUndefined = [
            ...util.dummyDataExcept(['string'], []),
            ...util.dummyData('string', {excludeTags: ['float']}),
            util.dummyData('string.float.negative')
        ];
        a.expect(mustReturnUndefined.length + 2);
        
        // make sure the function actually exists
        a.ok(is.function(MoodleVersion.branchNumberFromBranch), 'function exists');
        
        // make sure the data that should return undefined does
        for(const dd of mustReturnUndefined){
            a.ok(is.undefined(MoodleVersion.branchNumberFromBranch(dd.value)), `${dd.description} returns undefined`);
        }
        
        // make sure that values are converted as expected
        a.strictEqual(MoodleVersion.branchNumberFromBranch('3.5'), 35, "'3.5' converts to 35");
    });
    
    QUnit.test('branchNumberFromBranchingDateNumber()', function(a){
        const mustReturnUndefined = [
            ...util.dummyBasicDataExcept('number')
        ];
        a.expect(mustReturnUndefined.length + 5);
        
        // make sure the function actually exists
        a.ok(is.function(MoodleVersion.branchNumberFromBranchingDateNumber), 'function exists');
        
        // make sure the data that should return undefined does
        for(const dd of mustReturnUndefined){
            a.ok(is.undefined(MoodleVersion.branchNumberFromBranchingDateNumber(dd.value)), `${dd.description} returns undefined`);
        }
        
        // make sure valid data returns as expected
        a.strictEqual(MoodleVersion.branchNumberFromBranchingDateNumber(20180517), 35, '20180517 converts to 35');
        a.strictEqual(MoodleVersion.branchNumberFromBranchingDateNumber('20180517'), 35, "'20180517' converts to 35");
        a.ok(is.undefined(MoodleVersion.branchNumberFromBranchingDateNumber(20180513)), '20180513 converts to undefined (no such mapping)');
        a.ok(is.undefined(MoodleVersion.branchNumberFromBranchingDateNumber('20180513')),"'20180513' converts to undefined (no such mapping)");
    });
    
    QUnit.test('branchingDateNumberFromBranch()', function(a){
        const mustReturnUndefined = [
            ...util.dummyBasicDataExcept('string')
        ];
        a.expect(mustReturnUndefined.length + 3);
        
        // make sure the function actually exists
        a.ok(is.function(MoodleVersion.branchingDateNumberFromBranch), 'function exists');
        
        // make sure the data that should return undefined does
        for(const dd of mustReturnUndefined){
            a.ok(is.undefined(MoodleVersion.branchingDateNumberFromBranch(dd.value)), `${dd.description} returns undefined`);
        }
        
        // make sure valid data returns as expected
        a.strictEqual(MoodleVersion.branchingDateNumberFromBranch('3.5'), 20180517, "'3.5' converts to 20180517");
        a.ok(is.undefined(MoodleVersion.branchingDateNumberFromBranch('9.9')), "'9.9' converts to undefined (no such mapping)");
    });
    
    QUnit.test('branchingDateNumberFromBranchNumber()', function(a){
        const mustReturnUndefined = [
            ...util.dummyBasicDataExcept('number')
        ];
        a.expect(mustReturnUndefined.length + 5);
        
        // make sure the function actually exists
        a.ok(is.function(MoodleVersion.branchingDateNumberFromBranchNumber), 'function exists');
        
        // make sure the data that should return undefined does
        for(const dd of mustReturnUndefined){
            a.ok(is.undefined(MoodleVersion.branchingDateNumberFromBranchNumber(dd.value)), `${dd.description} returns undefined`);
        }
        
        // make sure valid data returns as expected
        a.strictEqual(MoodleVersion.branchingDateNumberFromBranchNumber(35), 20180517, '35 converts to 20180517');
        a.strictEqual(MoodleVersion.branchingDateNumberFromBranchNumber('35'), 20180517, "'35' converts to 20180517");
        a.ok(is.undefined(MoodleVersion.branchingDateNumberFromBranchNumber(99)), '99 converts to undefined (no such mapping)');
        a.ok(is.undefined(MoodleVersion.branchingDateNumberFromBranchNumber('99')),"'99' converts to undefined (no such mapping)");
    });
    
    QUnit.test('dateFromDateNumber()', function(a){
        const mustThrow = [
            ...util.dummyDataExcept(['number'], ['integer']),
            util.dummyData('number.integer.4digit'),
            util.dummyData('string.integer.4digit')
        ];
        a.expect(mustThrow.length + 3);
        
        // make sure the function actually exists
        a.ok(is.function(MoodleVersion.dateFromDateNumber), 'function exists');
        
        // make sure all values that should throw an error do
        for(const dd of mustThrow){
            a.throws(
                ()=>{ MoodleVersion.dateFromDateNumber(dd.value); },
                TypeError,
                `${dd.description} throws a type error`
            );
        }
        
        // make sure valid values are converted as expected
        let d = new Date('2018-05-01T00:00:00.000Z');
        a.strictEqual(MoodleVersion.dateFromDateNumber(20180501).toISOString(), d.toISOString(), '20180501 converts correctly');
        d = new Date('2018-12-25T00:00:00.000Z');
        a.strictEqual(MoodleVersion.dateFromDateNumber(20181225).toISOString(), d.toISOString(), '20181225 converts correctly');
    });
    
    QUnit.test('dateNumberFromDate()', function(a){
        const mustThrow = [
            ...util.dummyDataExcept(['object'], [], []),
            ...util.dummyData('object', {excludeTags: ['datetime']})
        ];
        a.expect(mustThrow.length + 3);
        
        // make sure the function actually exists
        a.ok(is.function(MoodleVersion.dateNumberFromDate), 'function exists');
        
        // make sure all values that should throw an error do
        for(const dd of mustThrow){
            a.throws(
                ()=>{ MoodleVersion.dateNumberFromDate(dd.value); },
                TypeError,
                `${dd.description} throws a type error`
            );
        }
        
        // make sure valid values are converted as expected
        a.strictEqual(MoodleVersion.dateNumberFromDate(new Date('2018-05-01T00:00:00.000Z')), 20180501, '2018-05-01T00:00:00.000Z converts to 20180501');
        a.strictEqual(MoodleVersion.dateNumberFromDate(new Date('2018-12-25T00:00:00.000Z')), 20181225, '2018-12-25T00:00:00.000Z converts to 20181225');
    });
    
    QUnit.test('releaseSuffixFromReleaseType()', function(a){
        const mustReturnUndefined = [
            ...util.dummyBasicData()
        ];
        a.expect(mustReturnUndefined.length + 7);
        
        // make sure the function actually exists
        a.ok(is.function(MoodleVersion.releaseSuffixFromReleaseType), 'function exists');
        
        // make sure that values that should return undefined do
        for(const dd of mustReturnUndefined){
            a.ok(is.undefined(MoodleVersion.releaseSuffixFromReleaseType(dd.value)), `${dd.description} returns undefined`);
        }
        
        // make sure the three valid values convert correctly, regardless of case
        a.strictEqual(MoodleVersion.releaseSuffixFromReleaseType('development'), 'dev', "'development' converts to 'dev'");
        a.strictEqual(MoodleVersion.releaseSuffixFromReleaseType('DEVELOPMENT'), 'dev', "'DEVELOPMENT' converts to 'dev'");
        a.strictEqual(MoodleVersion.releaseSuffixFromReleaseType('official'), '', "'official' converts to ''");
        a.strictEqual(MoodleVersion.releaseSuffixFromReleaseType('OFFICIAL'), '', "'OFFICIAL' converts to ''");
        a.strictEqual(MoodleVersion.releaseSuffixFromReleaseType('weekly'), '+', "'weekly' converts to '+'");
        a.strictEqual(MoodleVersion.releaseSuffixFromReleaseType('WEEKLY'), '+', "'WEEKLY' converts to '+'");
    });
    
    QUnit.test('releaseTypeFromReleaseSuffix()', function(a){
        const mustReturnUndefined = [
            ...util.dummyBasicData()
        ];
        a.expect(mustReturnUndefined.length + 5);
        
        // make sure the function actually exists
        a.ok(is.function(MoodleVersion.releaseTypeFromReleaseSuffix), 'function exists');
        
        // make sure that values that should return undefined do
        for(const dd of mustReturnUndefined){
            a.ok(is.undefined(MoodleVersion.releaseTypeFromReleaseSuffix(dd.value)), `${dd.description} returns undefined`);
        }
        
        // make sure the three valid values convert correctly, regardless of case
        a.strictEqual(MoodleVersion.releaseTypeFromReleaseSuffix('dev'), 'development', "'dev' converts to 'development'");
        a.strictEqual(MoodleVersion.releaseTypeFromReleaseSuffix('DEV'), 'development', "'DEV' converts to 'development'");
        a.strictEqual(MoodleVersion.releaseTypeFromReleaseSuffix(''), 'official', "'' converts to 'official'");
        a.strictEqual(MoodleVersion.releaseTypeFromReleaseSuffix('+'), 'weekly', "'+' converts to 'weekly'");
    });
});

QUnit.module('Getters & Setters', function(){
    QUnit.test('.branch & .branchNumber', function(a){
        // data that must throw errors
        const mustThrowBranchNumber = [
            ...util.dummyDataExcept([], ['integer'], ['other.undefined']),
            ...util.dummyDataWithAllTags('integer', 'negative'),
            ...util.dummyDataWithAnyTag('digit'),
            ...util.dummyDataWithAnyTag('3digit')
        ];
        const mustThrowBranch = [
            ...util.dummyDataExcept([], ['float'], ['other.undefined']),
            ...util.dummyDataWithAllTags('float', 'negative'),
        ];
        
        // matching lists of valid data
        const vbn  = [ 30,       33];       // valid branch numbers as numbers
        const vbns = ['30',     '33'];      // valid branch numbes as strings
        const vb   = ['3.0',    '3.3'];     // valid branches as strings
        const vbf  = [ 3.0,      3.3];      // valid branches as floating point numbers
        
        // set the number of expected tests
        a.expect(mustThrowBranchNumber.length + mustThrowBranch.length + (vbn.length * 6) + 7);
        
        // make sure the setters throws errors when needed
        for(const dd of mustThrowBranchNumber){
            a.throws(
                ()=>{
                    const v = new MoodleVersion();
                    v.branchNumber = dd.value;
                },
                TypeError,
                `.branchNumber throws error when attempting to set to ${dd.description}`
            );
        }
        for(const dd of mustThrowBranch){
            a.throws(
                ()=>{
                    const v = new MoodleVersion();
                    v.branch = dd.value;
                },
                TypeError,
                `.branch throws error when attempting to set to ${dd.description}`
            );
        }
        
        // make sure setting a branch number to a valid value does not throw an error and that the value gets correctly set
        for(let i = 0; i < vbn.length; i++){
            let v = new MoodleVersion();
            v.branchNumber = vbn[i];
            a.strictEqual(v.branchNumber, vbn[i], `branch number successfully set to ${vbn[i]}`);
            a.strictEqual(v.branch, vb[i], `branch number ${vbn[i]} successfully gotten as branch ${vb[i]}`);
            v.branchNumber = vbns[i];
            a.strictEqual(v.branchNumber, vbn[i], `branch number successfully set to '${vbns[i]}'`);
            v.branch = vb[i];
            a.strictEqual(v.branch, vb[i], `branch successfully set to '${vb[i]}'`);
            a.strictEqual(v.branchNumber, vbn[i], `branch '${vb[i]}' successfully gotten as branch number ${vbn[i]}`);
            a.strictEqual(v.branch, vb[i], `branch successfully set to ${vbf[i]}`);
        }
        
        // make sure unknown branch fails to set
        a.throws(
            ()=>{
                const v = new MoodleVersion();
                v.branchNumber = 21;
            },
            RangeError,
            'attempting to set branch number for unknown branch throws error'
        );
        a.throws(
            ()=>{
                const v = new MoodleVersion();
                v.branch = '2.1';
            },
            RangeError,
            'attempting to set unknown branch throws error'
        );
        
        // make sure matching branching date gets set
        let v = new MoodleVersion();
        v.branch = '3.3';
        a.strictEqual(v.branchingDateNumber, 20170515, 'setting known branch sets matching branching date');
        
        // make sure setting to undefined works, and also updates the branching date
        v.branch = undefined;
        a.ok(is.undefined(v.branch), 'branch can be set to undefined');
        a.ok(is.undefined(v.branchingDateNumber), 'setting branch undefined sets branching date to undefined too');
        v.branch = '3.3';
        v.branchNumber = undefined;
        a.ok(is.undefined(v.branchNumber), 'branch number can be set to undefined');
        a.ok(is.undefined(v.branchingDateNumber), 'setting branch number undefined sets branching date to undefined too');
    });
    
    QUnit.test('.branchindDate & .branchingDateNumber', function(a){
        // data that must throw errors
        const mustThrowBranchindDateNumber = [
            ...util.dummyDataExcept([], ['integer'], ['other.undefined']),
            ...util.dummyDataWithAllTags('integer', 'negative'),
            ...util.dummyDataWithAnyTag('digit'),
            ...util.dummyDataWithAnyTag('3digit')
        ];
        const mustThrowBranchingDate = [
            ...util.dummyBasicDataExcept('other')
        ];
        
        // set the number of expected tests
        a.expect(mustThrowBranchindDateNumber.length + mustThrowBranchingDate.length + 12);
        
        // make sure the setters throws errors when needed
        for(const dd of mustThrowBranchindDateNumber){
            a.throws(
                ()=>{
                    const v = new MoodleVersion();
                    v.branchingDateNumber = dd.value;
                },
                TypeError,
                `.branchingDateNumber throws error when attempting to set to ${dd.description}`
            );
        }
        for(const dd of mustThrowBranchingDate){
            a.throws(
                ()=>{
                    const v = new MoodleVersion();
                    v.branchingDate = dd.value;
                },
                TypeError,
                `.branchingDate throws error when attempting to set to ${dd.description}`
            );
        }
        
        // make sure setting a branching date to a valid value does not throw an error and that the value gets correctly set
        let v = new MoodleVersion();
        v.branchingDateNumber = 20170515; // Moodle 3.3
        a.strictEqual(v.branchingDateNumber, 20170515, 'branching date number successfully set to 20170515');
        let bd = v.branchingDate;
        a.ok(is.date(bd) && is.year(bd, 2017) && is.month(bd, 'may') && bd.getDate() === 15, `branching date number 20170515 successfully gotten as branching date ${bd}`);
        v.branchingDateNumber = '20170515'; // Moodle 3.3
        a.strictEqual(v.branchingDateNumber, 20170515, "branching date number successfully set to '20170515'");
        v.branchingDate = new Date('2018-05-17T00:00:00.000Z'); //Moodle 3.5
        bd = v.branchingDate;
        a.ok(is.date(bd) && is.year(bd, 2018) && is.month(bd, 'may') && bd.getDate() === 17, `branching date successfully set to ${bd}`);
        a.strictEqual(v.branchingDateNumber, 20180517, `branching date ${bd} successfully gotten as branching date number 20180517`);
        
        // make sure unknown branching date fails to set
        a.throws(
            ()=>{
                const v = new MoodleVersion();
                v.branchingDateNumber = 20170401;
            },
            RangeError,
            'attempting to set branching date number to date that does not match a know branch throws an error'
        );
        a.throws(
            ()=>{
                const v = new MoodleVersion();
                v.branchingDate = new Date('2018-04-01T00:00:00.000Z');
            },
            RangeError,
            'attempting to set branching date to date that does not match a know branch throws an error'
        );
        
        // make sure matching branch gets set
        v = new MoodleVersion();
        v.branchingDateNumber = 20170515;
        a.strictEqual(v.branchNumber, 33, 'setting known branching date sets matching branch');
        
        // make sure setting to undefined works, and also updates the branching date
        v.branchingDateNumber = undefined;
        a.ok(is.undefined(v.branchingDateNumber), 'branching date number can be set to undefined');
        a.ok(is.undefined(v.branchNumber), 'setting branching date number undefined sets branch to undefined too');
        v.branchingDateNumber = 20170515;
        v.branchingDate = undefined;
        a.ok(is.undefined(v.branchingDateNumber), 'branching date can be set to undefined');
        a.ok(is.undefined(v.branchNumber), 'setting branching date undefined sets branch to undefined too');
    });
    
    QUnit.test('.releaseNumber', function(a){
        // data that must throw errors
        const mustThrow = [
            ...util.dummyDataExcept([], ['integer'], ['other.undefined', 'string.empty']),
            ...util.dummyDataWithAllTags('integer', 'negative')
        ];
        
        // set the number of expected tests
        a.expect(mustThrow.length + 5);
        
        // make sure the setters throws errors when needed
        for(const dd of mustThrow){
            a.throws(
                ()=>{
                    const v = new MoodleVersion();
                    v.releaseNumber = dd.value;
                },
                TypeError,
                `.releaseNumber throws error when attempting to set to ${dd.description}`
            );
        }
        
        // make sure the release number can be set as a number and a string and read back
        let mv = new MoodleVersion();
        mv.releaseNumber = 7;
        a.strictEqual(mv.releaseNumber, 7, '.releaseNumber set to 7 and retrieved as 7');
        mv.releaseNumber = '11';
        a.strictEqual(mv.releaseNumber, 11, ".releaseNumber set to '11' and retrieved as 11");
        
        // make sure the release number can be set to zero, and can be undefined
        mv.releaseNumber = 0;
        a.strictEqual(mv.releaseNumber, 0, '.releaseNumber set to 0 and retried as 0');
        mv.releaseNumber = '';
        a.strictEqual(mv.releaseNumber, 0, ".releaseNumber set to '' and retried as 0");
        mv.releaseNumber = undefined;
        a.ok(is.undefined(mv.releaseNumber), '.releaseNumber can be set to undefined');
    });
    
    QUnit.test('.releaseType & .releaseSuffix', function(a){
        // data that must throw errors
        const mustThrowReleaseType = [
            ...util.dummyBasicDataExcept('other')
        ];
        const mustThrowReleaseSuffix = [
            ...util.dummyBasicDataExcept('other')
        ];
        
        // set the number of expected tests
        a.expect(mustThrowReleaseType.length + mustThrowReleaseSuffix.length + 12);
        
        // make sure the setters throws errors when needed
        for(const dd of mustThrowReleaseType){
            a.throws(
                ()=>{
                    const v = new MoodleVersion();
                    v.releaseType = dd.value;
                },
                TypeError,
                `.releaseType throws error when attempting to set to ${dd.description}`
            );
        }
        for(const dd of mustThrowReleaseSuffix){
            a.throws(
                ()=>{
                    const v = new MoodleVersion();
                    v.releaseSuffix = dd.value;
                },
                TypeError,
                `.releaseSuffix throws error when attempting to set to ${dd.description}`
            );
        }
        
        // make sure valid release types can be set and read back
        let mv = new MoodleVersion();
        mv.releaseType = 'development';
        a.strictEqual(mv.releaseType, 'development', "successfully set releaseType to 'development' and read back");
        a.strictEqual(mv.releaseSuffix, 'dev', "successfully set releaseType to 'development' and read as suffix 'dev'");
        mv.releaseType = 'official';
        a.strictEqual(mv.releaseType, 'official', "successfully set releaseType to 'official' and read back");
        a.strictEqual(mv.releaseSuffix, '', "successfully set releaseType to 'official' and read as suffix ''");
        mv.releaseType = 'weekly';
        a.strictEqual(mv.releaseType, 'weekly', "successfully set releaseType to 'weekly' and read back");
        a.strictEqual(mv.releaseSuffix, '+', "successfully set releaseType to 'weekly' and read as suffix '+'");
        
        // make sure valid release suffixes can be set and read back
        mv.releaseSuffix = 'dev';
        a.strictEqual(mv.releaseSuffix, 'dev', "successfully set releaseSuffix to 'dev' and read back");
        a.strictEqual(mv.releaseType, 'development', "successfully set releaseSuffix to 'dev' and read as type 'development'");
        mv.releaseSuffix = '';
        a.strictEqual(mv.releaseSuffix, '', "successfully set releaseSuffix to '' and read back");
        a.strictEqual(mv.releaseType, 'official', "successfully set releaseSuffix to '' and read as type 'official'");
        mv.releaseSuffix = '+';
        a.strictEqual(mv.releaseSuffix, '+', "successfully set releaseSuffix to '+' and read back");
        a.strictEqual(mv.releaseType, 'weekly', "successfully set releaseSuffix to '+' and read as type 'weekly'");
    });
    
    QUnit.test('.buildNumber', function(a){
        // data that must throw errors
        const mustThrow = [
            ...util.dummyDataExcept([], ['integer'], ['other.undefined']),
            ...util.dummyDataWithAllTags('integer', 'negative'),
            ...util.dummyDataWithAnyTag('digit'),
            ...util.dummyDataWithAnyTag('3digit')
        ];
        
        // set the number of expected tests
        a.expect(mustThrow.length + 3);
        
        // make sure the setters throws errors when needed
        for(const dd of mustThrow){
            a.throws(
                ()=>{
                    const v = new MoodleVersion();
                    v.buildNumber = dd.value;
                },
                TypeError,
                `.buildNumber throws error when attempting to set to ${dd.description}`
            );
        }
        
        // make sure the build number can be set as a number and a string and read back
        let mv = new MoodleVersion();
        mv.buildNumber = 20180622;
        a.strictEqual(mv.buildNumber, 20180622, '.buildNumber set to 20180622 and retrieved as 20180622');
        mv.buildNumber = '20180623';
        a.strictEqual(mv.buildNumber, 20180623, ".releaseNumber set to '20180623' and retrieved as 20180623");
        
        // make sure the build number can be set undefined
        mv.buildNumber = undefined;
        a.ok(is.undefined(mv.buildNumber), '.buildNumber can be set to undefined');
    });
});

QUnit.module('Object Utility Functions', function(){
    QUnit.test('.clone()', function(a){
        const propertiesToTest = ['_branchNumber', '_branchingDateNumber', '_releaseNumber', '_releaseType', '_buildNumber'];
        a.expect((propertiesToTest.length * 3) + 3);
        
        // make sure the function actually exists
        a.ok(is.function(MoodleVersion.prototype.clone), 'function exists');
        
        // make sure the clone really is a clone object
        let v = new MoodleVersion();
        let vc = v.clone();
        a.ok(vc instanceof MoodleVersion, 'clone is a MoodleVersion object');
        a.notStrictEqual(v, vc, 'the clone is not a reference to the original');
        
        // make sure all values get coppied when undefined
        for(const p of propertiesToTest){
            a.strictEqual(v[p], vc[p], `property ${p} coppied correctly when undefined`);
        }
        
        // make sure all values get coppied with a known version
        v = MoodleVersion.fromObject({
            branchNumber: 35,
            releaseNumber: 0,
            releaseType: 'weekly',
            buildNumber: 20180614
        });
        vc = v.clone();
        for(const p of propertiesToTest){
            a.strictEqual(v[p], vc[p], `property ${p} coppied correctly on known version`);
        }
        
        // make sure all values get coppied with an unknown version
        v = MoodleVersion.fromObject({
            branchNumber: 36,
            branchingDateNumber: 20180517,
            releaseNumber: 0,
            releaseType: 'development',
            buildNumber: 20180524
        });
        vc = v.clone();
        for(const p of propertiesToTest){
            a.strictEqual(v[p], vc[p], `property ${p} coppied correctly on an unknown version`);
        }
    });
    
    QUnit.test('.toString()', function(a){
        a.expect(6);
        
        // make sure the function actually exists
        a.ok(is.function(MoodleVersion.prototype.toString), 'function exists');
        
        // make sure the function returns a string
        let v = new MoodleVersion();
        a.ok(is.string(v.toString()), 'returns a string');
        
        // make sure the function can handle an empty object
        a.strictEqual(v.toString(), '??.??.?? (type: ??, branching date: ?? & build: ??)', 'empty object rendered correctly');
        
        // make sure the function correctly includes all data
        v = MoodleVersion.fromObject({
            branchNumber: 35,
            releaseNumber: 0,
            releaseType: 'official',
            buildNumber: 20180614
        });
        a.strictEqual(v.toString(), '3.5.0 (type: official, branching date: 20180517 & build: 20180614)', 'complete version rendered correctly');
        
        // make sure the function correctly handles the suffixes
        v.releaseType = 'development';
        a.strictEqual(v.toString(), '3.5.0dev (type: development, branching date: 20180517 & build: 20180614)', 'dev version rendered correctly');
        v.releaseType = 'weekly';
        a.strictEqual(v.toString(), '3.5.0+ (type: weekly, branching date: 20180517 & build: 20180614)', 'weekly version rendered correctly');
    });
});

QUnit.module('comparison methods', function(){
    QUnit.test('compare()', function(a){
        const mustReturnNaN = [
            ...util.dummyBasicData()
        ];
        a.expect((mustReturnNaN.length * 2) + 11);
        
        // make sure the function actually exists
        a.ok(is.function(MoodleVersion.compare), 'function exists');
        
        // make sure everything that must result in NaN does when used as either argument
        const v = new MoodleVersion();
        for(const dd of mustReturnNaN){
            a.ok(is.nan(MoodleVersion.compare(dd.value, v)), `${dd.description} as val1 returns NaN`);
            a.ok(is.nan(MoodleVersion.compare(v, dd.value)), `${dd.description} as val2 returns NaN`);
        }
        
        // check that equality is properly detected, both on an 'empty' version and one with all details added
        a.strictEqual(MoodleVersion.compare(new MoodleVersion(), new MoodleVersion()), 0, 'two default versions are considered equal');
        let vObj = {
            branch: '3.5',
            releaseNumber: 0,
            releaseType: 'weekly',
            buildNumber: 20180614
        };
        a.strictEqual(MoodleVersion.compare(new MoodleVersion(vObj), new MoodleVersion(vObj)), 0, 'two versions with the same branch, release number, type & build number are considered equal');
        
        // check when branches differ
        let v1 = MoodleVersion.fromObject({
            branch: '3.3',
            releaseNumber: '6',
            releaseType: 'official',
            buildNumber: 20180517
        });
        let v2 = MoodleVersion.fromObject({
            branch: '3.4',
            releaseNumber: '6',
            releaseType: 'official',
            buildNumber: 20180517
        });
        a.strictEqual(MoodleVersion.compare(v1, v2), -1, 'val1 with lower branch than val2 returns -1');
        a.strictEqual(MoodleVersion.compare(v2, v1), 1, 'val1 with higher branch than val2 returns 1');
        
        // check when release numbers differ
        v1 = MoodleVersion.fromObject({
            branch: '3.3',
            releaseNumber: '6',
            releaseType: 'official',
            buildNumber: 20180517
        });
        v2 = MoodleVersion.fromObject({
            branch: '3.3',
            releaseNumber: '7',
            releaseType: 'official',
            buildNumber: 20180517
        });
        a.strictEqual(MoodleVersion.compare(v1, v2), -1, 'val1 with lower release number than val2 returns -1');
        a.strictEqual(MoodleVersion.compare(v2, v1), 1, 'val1 with higher release number than val2 returns 1');
        
        // check when release types differ
        v1 = MoodleVersion.fromObject({
            branch: '3.3',
            releaseNumber: '6',
            releaseType: 'official',
            buildNumber: 20180517
        });
        v2 = MoodleVersion.fromObject({
            branch: '3.3',
            releaseNumber: '6',
            releaseType: 'weekly',
            buildNumber: 20180517
        });
        a.strictEqual(MoodleVersion.compare(v1, v2), -1, 'val1 with lower release type than val2 returns -1');
        a.strictEqual(MoodleVersion.compare(v2, v1), 1, 'val1 with higher release type than val2 returns 1');
        
        // check when release types differ
        v1 = MoodleVersion.fromObject({
            branch: '3.3',
            releaseNumber: '6',
            releaseType: 'weekly',
            buildNumber: 20180517
        });
        v2 = MoodleVersion.fromObject({
            branch: '3.3',
            releaseNumber: '6',
            releaseType: 'weekly',
            buildNumber: 20180524
        });
        a.strictEqual(MoodleVersion.compare(v1, v2), -1, 'val1 with lower build number than val2 returns -1');
        a.strictEqual(MoodleVersion.compare(v2, v1), 1, 'val1 with higher build number than val2 returns 1');
    });
    
    QUnit.test('.equals()', function(a){
        const mustReturnFalse = [
            ...util.dummyBasicData()
        ];
        a.expect(mustReturnFalse.length + 8);
        
        // make sure the function actually exists
        a.ok(is.function(MoodleVersion.prototype.equals), 'function exists');
        
        // make sure values other than version objects return false
        const vObj = {
            branch: '3.3',
            releaseNumber: '6',
            releaseType: 'official',
            buildNumber: 20180517
        };
        const v = MoodleVersion.fromObject(vObj);
        for(const dd of mustReturnFalse){
            a.strictEqual(v.equals(dd.val), false, `${dd.description} returns false`);
        }
        
        // make sure equal versions return true
        let vd = new MoodleVersion();
        a.strictEqual(vd.equals(new MoodleVersion()), true, 'a default version is considered equal to another default version');
        a.strictEqual(v.equals(v.clone()), true, 'a clone is considered equal to the original');
        a.strictEqual(v.equals(MoodleVersion.fromObject(vObj)), true, 'two versions containing the same branch, release number, type, and build number are considered equal');
        
        // make sure differing versions return false
        a.strictEqual(v.equals(MoodleVersion.fromObject(_.assign({}, vObj, { branch: '3.4'}))), false, 'differing branch not considered equal');
        a.strictEqual(v.equals(MoodleVersion.fromObject(_.assign({}, vObj, { releaseNumber: '7'}))), false, 'differing release number not considered equal');
        a.strictEqual(v.equals(MoodleVersion.fromObject(_.assign({}, vObj, { releaseType: 'weekly'}))), false, 'differing release type not considered equal');
        a.strictEqual(v.equals(MoodleVersion.fromObject(_.assign({}, vObj, { buildNumber: 20180518}))), false, 'differing release number not considered equal');
    });
    
    QUnit.test('.compareTo()', function(a){
        const mustReturnNaN = [
            ...util.dummyBasicData()
        ];
        a.expect(mustReturnNaN.length + 10);
        
        // make sure the function actually exists
        a.ok(is.function(MoodleVersion.prototype.compareTo), 'function exists');
        
        // make sure values other than version objects return NaN
        const vObj = {
            branch: '3.3',
            releaseNumber: '6',
            releaseType: 'official',
            buildNumber: 20180517
        };
        const v = MoodleVersion.fromObject(vObj);
        for(const dd of mustReturnNaN){
            a.ok(is.nan(v.compareTo(dd.val)), `${dd.description} returns NaN`);
        }
        
        // make sure an equal version returns 0
        a.strictEqual(v.compareTo(MoodleVersion.fromObject(vObj)), 0, 'an equal version returns 0');
        
        // make sure lesser versions return -1
        a.strictEqual(v.compareTo(MoodleVersion.fromObject(_.assign({}, vObj, { branch: '3.2'}))), -1, 'lower branch returns -1');
        a.strictEqual(v.compareTo(MoodleVersion.fromObject(_.assign({}, vObj, { releaseNumber: 5}))), -1, 'lower release number returns -1');
        a.strictEqual(v.compareTo(MoodleVersion.fromObject(_.assign({}, vObj, { releaseType: 'development'}))), -1, 'dev release returns -1');
        a.strictEqual(v.compareTo(MoodleVersion.fromObject(_.assign({}, vObj, { buildNumber: 20180510}))), -1, 'lower build number returns -1');
        
        // make sure greater versions return false
        a.strictEqual(v.compareTo(MoodleVersion.fromObject(_.assign({}, vObj, { branch: '3.4'}))), 1, 'higher branch returns 1');
        a.strictEqual(v.compareTo(MoodleVersion.fromObject(_.assign({}, vObj, { releaseNumber: 7}))), 1, 'higher release number returns 1');
        a.strictEqual(v.compareTo(MoodleVersion.fromObject(_.assign({}, vObj, { releaseType: 'weekly'}))), 1, 'weekly release returns 1');
        a.strictEqual(v.compareTo(MoodleVersion.fromObject(_.assign({}, vObj, { buildNumber: 20180524}))), 1, 'higher build number returns 1');
    });
    
    QUnit.test('.lessThan()', function(a){
        const mustReturnUndefined = [
            ...util.dummyBasicData()
        ];
        a.expect(mustReturnUndefined.length + 10);
        
        // make sure the function actually exists
        a.ok(is.function(MoodleVersion.prototype.lessThan), 'function exists');
        
        // make sure values other than version objects return undefined
        const vObj = {
            branch: '3.3',
            releaseNumber: '6',
            releaseType: 'official',
            buildNumber: 20180517
        };
        const v = MoodleVersion.fromObject(vObj);
        for(const dd of mustReturnUndefined){
            a.ok(is.undefined(v.lessThan(dd.val)), `${dd.description} returns undefined`);
        }
        
        // make sure an equal version returns false
        a.strictEqual(v.lessThan(MoodleVersion.fromObject(vObj)), false, 'an equal version is not considered lesser');
        
        // make sure lesser versions return true
        a.strictEqual(v.lessThan(MoodleVersion.fromObject(_.assign({}, vObj, { branch: '3.2'}))), true, 'lower branch considered less than');
        a.strictEqual(v.lessThan(MoodleVersion.fromObject(_.assign({}, vObj, { releaseNumber: 5}))), true, 'lower release number considered less than');
        a.strictEqual(v.lessThan(MoodleVersion.fromObject(_.assign({}, vObj, { releaseType: 'development'}))), true, 'dev release considered less than official release');
        a.strictEqual(v.lessThan(MoodleVersion.fromObject(_.assign({}, vObj, { buildNumber: 20180510}))), true, 'lower build number considered less than');
        
        // make sure greater versions return false
        a.strictEqual(v.lessThan(MoodleVersion.fromObject(_.assign({}, vObj, { branch: '3.4'}))), false, 'higher branch not considered less than');
        a.strictEqual(v.lessThan(MoodleVersion.fromObject(_.assign({}, vObj, { releaseNumber: 7}))), false, 'higher release number not considered less than');
        a.strictEqual(v.lessThan(MoodleVersion.fromObject(_.assign({}, vObj, { releaseType: 'weekly'}))), false, 'weekly release not considered less than official release');
        a.strictEqual(v.lessThan(MoodleVersion.fromObject(_.assign({}, vObj, { buildNumber: 20180524}))), false, 'higher build number not considered less than');
    });
    
    QUnit.test('.greaterThan()', function(a){
        const mustReturnUndefined = [
            ...util.dummyBasicData()
        ];
        a.expect(mustReturnUndefined.length + 10);
        
        // make sure the function actually exists
        a.ok(is.function(MoodleVersion.prototype.greaterThan), 'function exists');
        
        // make sure values other than version objects return undefined
        const vObj = {
            branch: '3.3',
            releaseNumber: '6',
            releaseType: 'official',
            buildNumber: 20180517
        };
        const v = MoodleVersion.fromObject(vObj);
        for(const dd of mustReturnUndefined){
            a.ok(is.undefined(v.greaterThan(dd.val)), `${dd.description} returns undefined`);
        }
        
        // make sure an equal version returns false
        a.strictEqual(v.greaterThan(MoodleVersion.fromObject(vObj)), false, 'an equal version is not considered greater');
        
        // make sure lesser versions return false
        a.strictEqual(v.greaterThan(MoodleVersion.fromObject(_.assign({}, vObj, { branch: '3.2'}))), false, 'lower branch not considered greater');
        a.strictEqual(v.greaterThan(MoodleVersion.fromObject(_.assign({}, vObj, { releaseNumber: 5}))), false, 'lower release number not considered greater');
        a.strictEqual(v.greaterThan(MoodleVersion.fromObject(_.assign({}, vObj, { releaseType: 'development'}))), false, 'dev release not considered gerater than official release');
        a.strictEqual(v.greaterThan(MoodleVersion.fromObject(_.assign({}, vObj, { buildNumber: 20180510}))), false, 'lower build number not considered greater');
        
        // make sure greater versions return true
        a.strictEqual(v.greaterThan(MoodleVersion.fromObject(_.assign({}, vObj, { branch: '3.4'}))), true, 'higher branch considered greater');
        a.strictEqual(v.greaterThan(MoodleVersion.fromObject(_.assign({}, vObj, { releaseNumber: 7}))), true, 'higher release number considered greater');
        a.strictEqual(v.greaterThan(MoodleVersion.fromObject(_.assign({}, vObj, { releaseType: 'weekly'}))), true, 'weekly release considered greater than official release');
        a.strictEqual(v.greaterThan(MoodleVersion.fromObject(_.assign({}, vObj, { buildNumber: 20180524}))), true, 'higher build number considered greater');
    });
    
    QUnit.test('.sameBranch()', function(a){
        const mustReturnUndefined = [
            ...util.dummyBasicData()
        ];
        a.expect(mustReturnUndefined.length + 8);
        
        // make sure the function actually exists
        a.ok(is.function(MoodleVersion.prototype.sameBranch), 'function exists');
        
        // make sure values other than version objects return undefined
        const vObj = {
            branch: '3.3',
            releaseNumber: '6',
            releaseType: 'official',
            buildNumber: 20180517
        };
        const v = MoodleVersion.fromObject(vObj);
        for(const dd of mustReturnUndefined){
            a.ok(is.undefined(v.sameBranch(dd.val)), `${dd.description} returns undefined`);
        }
        a.ok(is.undefined((new MoodleVersion()).sameBranch(new MoodleVersion())), 'two undefined branches returns undefined');
        
        // make sure an equal version returns true
        a.strictEqual(v.sameBranch(MoodleVersion.fromObject(vObj)), true, 'an equal version is considered the same branch');
        
        // make sure same branch returns true
        a.strictEqual(v.sameBranch(MoodleVersion.fromObject(_.assign({}, vObj, { releaseNumber: 5}))), true, 'differing release number considered same branch');
        a.strictEqual(v.sameBranch(MoodleVersion.fromObject(_.assign({}, vObj, { releaseType: 'development'}))), true, 'differing release type considered same branch');
        a.strictEqual(v.sameBranch(MoodleVersion.fromObject(_.assign({}, vObj, { buildNumber: 20180510}))), true, 'differing build number considered same branch');
        
        // make sure differing branch returns false
        a.strictEqual(v.sameBranch(MoodleVersion.fromObject(_.assign({}, vObj, { branch: '3.4'}))), false, 'lower branch considered different branch');
        a.strictEqual(v.sameBranch(MoodleVersion.fromObject(_.assign({}, vObj, { branch: '3.6'}))), false, 'higher branch considered different branch');
    });
});

QUnit.module('informational methods', function(){
    QUnit.test('.isKnownBranch()', function(a){
        a.expect(4);
        
        // make sure the function actually exists
        a.ok(is.function(MoodleVersion.prototype.isKnownBranch), 'function exists');
        
        // make sure undefined and unknown branches return false
        a.strictEqual((new MoodleVersion()).isKnownBranch(), false, 'an undefined branch returns false');
        a.strictEqual(MoodleVersion.fromObject({branch: '2.1'}).isKnownBranch(), false, 'an unknown branch returns false');
        
        // make sure a known branch returns true
        a.strictEqual(MoodleVersion.fromObject({branch: '3.3'}).isKnownBranch(), true, 'a known branch returns true');
    });
    
    QUnit.test('.isStable()', function(a){
        a.expect(5);
        
        // make sure the function actually exists
        a.ok(is.function(MoodleVersion.prototype.isStable), 'function exists');
        
        // make sure an undefined release type returns undefined
        a.ok(is.undefined((new MoodleVersion()).isStable()), 'an undefined release type returns undefined');
        
        // make sure dev returns false
        a.strictEqual(MoodleVersion.fromObject({releaseType: 'development'}).isStable(), false, 'develpment release returns false');
        
        // make sure official and weekly retun true
        a.strictEqual(MoodleVersion.fromObject({releaseType: 'official'}).isStable(), true, 'official release returns true');
        a.strictEqual(MoodleVersion.fromObject({releaseType: 'weekly'}).isStable(), true, 'weekly release returns true');
    });
    
    QUnit.test('.isLTS()', function(a){
        a.expect(5);
        
        // make sure the function actually exists
        a.ok(is.function(MoodleVersion.prototype.isLTS), 'function exists');
        
        // make sure a undefined and unknown branches return undefined
        a.ok(is.undefined((new MoodleVersion()).isLTS()), 'an undefined branch returns undefined');
        a.ok(is.undefined(MoodleVersion.fromObject({branch: '2.1'}).isLTS()), 'an unknown branch returns undefined');
        
        // make sure a known non-LTS branch returns false
        a.strictEqual(MoodleVersion.fromObject({branch: '3.3'}).isLTS(), false, 'a known non-LTS branch returns false');
        
        // make sure a known LTS branch returns true
        a.strictEqual(MoodleVersion.fromObject({branch: '3.5'}).isLTS(), true, 'a known LTS branch returns true');
    });
});

QUnit.module('factory methods', function(){
    QUnit.test('fromObject()', function(a){
        const mustThrow = [
            ...util.dummyBasicPrimitives()
        ];
        const props = ['_branchNumber', '_branchingDateNumber', '_releaseNumber', '_releaseType', '_buildNumber'];
        a.expect(mustThrow.length + (props.length * 3) + 5);
        
        // make sure the function actually exists
        a.ok(is.function(MoodleVersion.fromObject), 'function exists');
        
        // make sure data that should throw an error does
        for(const dd of mustThrow){
            a.throws(
                ()=>{ MoodleVersion.fromObject(dd.value); },
                TypeError,
                `${dd.description} throws a type error`
            );
        }
        
        // make sure an empty object is treated correctly
        let v = MoodleVersion.fromObject({});
        for(const p of props){
            a.ok(is.undefined(v[p]), `${p} undefined when passed empty object`);
        }
        
        // a helper function to quickly check all properties against an array of values
        checkAllProps = (msg, ...vals)=>{
            for(let i = 0; i < props.length; i++){
                a.strictEqual(v[props[i]], vals[i], `${props[i]} ${msg}`);
            }
        };
        
        // make sure all properties get saved when given the natively stored data for a valid branch
        // this test covers auto-fill of branching dates
        v = MoodleVersion.fromObject({
            branchNumber: 33,
            releaseNumber: 6,
            releaseType: 'official',
            buildNumber: 20180517
        });
        checkAllProps('correctly saved when passed native data for valid branch', 33, 20170515, 6, 'official', 20180517);
        
        // make sure all properties get saved when given auto-translated data for a valid branch
        v = MoodleVersion.fromObject({
            branch: '3.3',
            releaseNumber: 6,
            releaseSuffix: '',
            buildNumber: 20180517
        });
        checkAllProps('correctly saved when passed data that needs transforming for valid branch', 33, 20170515, 6, 'official', 20180517);
        
        // make sure branches auto-fill to branching dates
        v = MoodleVersion.fromObject({
            branchingDateNumber: 20170515,
            releaseNumber: 6,
            releaseSuffix: '',
            buildNumber: 20180517
        });
        a.strictEqual(v._branchNumber, 33, 'Branch correctly auto-filled from brancing date number');
        v = MoodleVersion.fromObject({
            branchingDate: new Date('2017-05-15T00:00:00.000Z'),
            releaseNumber: 6,
            releaseSuffix: '',
            buildNumber: 20180517
        });
        a.strictEqual(v._branchNumber, 33, 'Branch correctly auto-filled from brancing date');
        
        // make sure un-known branches can be created
        v = MoodleVersion.fromObject({
            branchNumber: 36,
            branchingDateNumber: 20180615,
            releaseNumber: 0,
            releaseSuffix: 'dev',
            buildNumber: 20180618
        });
        a.strictEqual(v._branchNumber, 36, 'un-known branch successfully saved');
        a.strictEqual(v._branchingDateNumber, 20180615, 'un-known branching date successfully saved');
    });
});