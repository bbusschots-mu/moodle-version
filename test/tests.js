//
//=== TEMP Utilities 'Module' ==================================================
//
// (will be separated out into an actual module when up and working)

/**
 * A dummy data definition encapsulating the piece of data itself, a
 * description, and one or more tags.
 */
class DummyData{
    
    /**
     * @param {string} desc - a description of the piece of data.
     * @param {string[]} tags - zero or more tags to associate with the data.
     * @param {*} val - the actual piece of data.
     */
    constructor(desc, tags, val){
        if(!(is.string(desc) && is.not.empty(desc))) throw new TypeError('description must be a non-empty string');
        if(!(is.array(tags) && is.all.string(tags))) throw new TypeError('tags must be an array of strings');
        this._description = desc;
        this._tags = [...tags];
        this._value = val;
        this._tagLookup = {};
        for(const t of this._tags){
            this._tagLookup[t] = true;
        }
    }
    
    /*
     * @type {string}
     */
    get description(){
        return this._description;
    }
    
    /**
     * @type {string[]}
     */
    get tags(){
        return this._tags;
    }
    
    /**
     * @type {*}
     */
    get value(){
        return this._value;
    }
    
    
    hasTag(t){
        if(is.not.string(t)) throw new TypeError('tag must be a string');
        return this._tagLookup[t] ? true : false;
    }
}

/**
 * A utility 'module' for tests. Will be broken out into a separate project
 * later.
 */
const util = {
    /**
     * The library of dummy data organised by type and period-separated tag
     * path.
     *
     * This data structure is generated by the `.refreshDummyData()` function.
     * 
     * @type {Map<string, Map<string, DummyData>>}
     */
    allDummyData: {},
    refreshDummyData: function(){
        /**
         * Enter dummy data into this data structure. This will then be
         * transformed into the final output automatically
         *
         * The data structure is organised by type, and then by period-separated
         * tag-path.
         *
         * Each piece of dummy data is represented as a three-value array where
         * the first element is a string descriving the value, the second an
         * array of additional tags, and the third the value itself.
         *
         * The individual parts of the tag path and the additional tags are
         * combined to assemble the tags propert, so don't replicate tags in
         * both places
         *
         * @type {Map<string, Map<string, Array>>}
         * @private
         */
        const rawData = {
            'boolean': {
                'true': ['true', [], true],
                'false': ['false', ['falsy'], false]
            },
            'number': {
                'zero': ['the number zero', ['integer', 'falsy'], 0],
                'integer': ['a positive integer', [], 12345],
                'integer.digit': ['a single-digit number', [], 7],
                'integer.2digit': ['a 2-digit number', [], 42],
                'integer.3digit': ['a 3-digit number', [], 123],
                'integer.4digit': ['a 4-digit number', [], 1982],
                'integer.negative': ['a negative integer', [], -12345],
                'float': ['a positive floating point number', [], 3.14],
                'float.negative': ['a negative floating point number', [], -3.14]
            },
            'string': {
                'empty': ['an empty string', ['falsy'], ''],
                'word': ['a single-word string', [], 'boogers'],
                'line': ['a single-line string', [], 'boogers and snot'],
                'multiline': ['a multi-line string', [''], 'boogers\nsnot\nbogeys'],
                'zero': ['the digit 0', ['integer', 'numeric'], '0'],
                'digit': ['a single-digit number', ['integer', 'numeric'], '7'],
                'integer': ['a positive integer string', ['numeric'], '12345'],
                'integer.2digit': ['a 2-digit number', ['numeric'], '42'],
                'integer.3digit': ['a 3-digit number', ['numeric'], '123'],
                'integer.4digit': ['a 4-digit number', ['numeric'], '1982'],
                'integer.negative': ['a negative integer string', ['numeric'], '-12345'],
                'float': ['a floating point numeric string', ['numeric'], '3.14'],
                'float.negative': ['a negative floating point numeric string', ['numeric'], '-3.14']
            },
            'array': {
                'empty': ['an empty array', [], []],
                'basic': ['an array of primitives', [], [true, 42, 'boogers']]
            },
            'object': {
                'null': ['null', ['empty', 'falsy'], null],
                'empty': ['empty object', ['plain'], {}],
                'plain': ['a plain object', [], {a: 'b', c: 42, d: true}]
            },
            'function': {
                'void': ['a void function', [], function(){}]
            },
            'other': {
                "undefined": ['undefined', ['empty', 'falsy'], undefined]
            }
        };
        const ans = {};
        for(const t of Object.keys(rawData)){
            ans[t] = {};
            for(const tp of Object.keys(rawData[t])){
                ans[t][tp] = new DummyData(
                    rawData[t][tp][0],
                    [...tp.split('.'), ...rawData[t][tp][1]],
                    rawData[t][tp][2]
                );
            }
        }
        this.allDummyData = ans;
    },
    
    /**
     * Returns a single piece of dummy data, or, all the dummy data for a
     * given type, or all the dummy data.
     *
     * To get a single piece of dummy data pass its type and tag path as a
     * single period-separated string, e.g. `'string.word'` for the dummy data
     * with type `string` and tag path `word`, or `'number.integer.negative'`
     * for the dummy data with type `number` and tag path `integer.negative`.
     *
     * To get all the dummy data for a given type pass the type as a string,
     * e.g. `'boolean'` for all dummy boolean data.
     *
     * To get all the dummy data, simply pass `'*'`.
     *
     * When querying all the dummy data both entire sections and specific tags
     * can be excluded, and when querying all the dummy data for a sigle type
     * specific tags can be excluded.
     *
     * @param {string} path - a type, or, a type and tag path as a single
     * period-separated string, or the special value `'*'`.
     * @param {object?} opts - an optional options object.
     * @param {string[]?} opts.excludeTypes - a list of types to exclude when
     * requesting all dummy data (`path` is `'*'`).
     * @param {string[]?} opts.excludeTags - a list of tags to exclude when
     * requesting all dummy data, or the dummy data for a given type.
     * @return {DummyData[]|DummyData|undefined} Returns all the dummy data
     * for a given type, or a single piece of dummy data for a type with tag
     * path. If only a type is passed and that type does not exist an empty
     * array is returned, if the path has two or more parts and the type or
     * tag path don't exist, `undefined` is returned.
     * @throws {TypeError}
     */
    dummyData: function(path, opts){
        if(!(is.string(path) && is.not.empty(path))) throw new TypeError('path must be a non-empty string');
        if(is.not.object(opts)) opts = {};
        const pathParts = path.split('.');
        const reqType = pathParts[0];
        
        // if a single piece of data or a single type is requested, and does not exist, return
        if(reqType !== '*'){
            if(is.not.object(this.allDummyData[reqType])) return pathParts.length === 1 ? [] : undefined;
        }
        
        // deal with requests for a single piece of data
        if(pathParts.length > 1) return this.allDummyData[reqType][pathParts.slice(1).join('.')];
        
        // deal with requests for data for one or more types
        
        // figure out what types to process
        const typesToFetch = [];
        if(reqType === '*'){
            const typeSkipLookup = {};
            if(is.array(opts.excludeTypes)){
                for(const t of opts.excludeTypes) typeSkipLookup[t] = true;
            }
            for(const t of Object.keys(this.allDummyData)){
                if(!typeSkipLookup[t]) typesToFetch.push(t);
            }
        }else{
            typesToFetch.push(reqType);
        }
        
        // process all the requested types
        const ans = [];
        const doCheckTags = is.array(opts.excludeTags);
        for(const t of typesToFetch){
            processTypeDummyData:
            for(const tp of Object.keys(this.allDummyData[t])){
                if(doCheckTags){
                    for(const et of opts.excludeTags){
                        if(this.allDummyData[t][tp].hasTag(et)) continue processTypeDummyData;
                    }
                }
                ans.push(this.allDummyData[t][tp]);
            }
        }
        return ans;
    },
    
    /**
     * A function to return all dummy data except those for the given
     * types and those matching the given tags tags.
     *
     * This is a shortcut for
     * `.dummyData('*', {excludeTypes: arguments[0], excludeTags: arguments[1]})`
     *
     * @param {string[]?} excludeTypes
     * @param {string[]?} excludeTags
     * @return DummyData[]
     */
    dummyDataExcept: function(excludeTypes, excludeTags){
        if(is.not.array(excludeTypes)) excludeTypes = [];
        if(is.not.array(excludeTags)) excludeTags = [];
        return this.dummyData('*', {excludeTypes, excludeTags});
    },
    
    /**
     * Returns the dummy data of one or more types.
     * 
     * @param {...string} typeList
     * @return {DummyData[]}
     * @throws {TypeError}
     */
    dummyDataByType: function(...typeList){
        if(!is.all.string(typeList)) throw new TypeError('all specified types must be strings');
        const ans = [];
        for(const t of typeList){
            if(is.object(this.allDummyData[t])) ans.push(...Object.values(this.allDummyData[t]));
        }
        return ans;
    },
    
    /**
     * Returns the dummy data matching one or more tags.
     * 
     * @param {...string} tagList
     * @return {DummyData[]}
     * @throws {TypeError}
     */
    dummyDataByTag: function(...tagList){
        if(!is.all.string(tagList)) throw new TypeError('all specified tags must be strings');
        const ans = [];
        for(const td of Object.values(this.allDummyData)){
            for(const dd of Object.values(td)){
                for(const t of tagList){
                    if(dd.hasTag(t)){
                        ans.push(dd);
                        break;
                    }
                }
            }
            
        }
        return ans;
    }
};

// initialise the dummy data
util.refreshDummyData();

//
//=== The Tests ================================================================
//

QUnit.module('Static Helpers', {}, function(){
    QUnit.test('branchFromBranchNumber()', function(a){
        const mustReturnUndefined = [
            ...util.dummyDataExcept([], ['2digit'])
        ];
        a.expect(mustReturnUndefined.length + 3);
        
        // make sure the function actually exists
        a.ok(is.function(MoodleVersion.branchFromBranchNumber), 'function exists');
        
        // make sure the data that should return undefined does
        for(const dd of mustReturnUndefined){
            a.ok(is.undefined(MoodleVersion.branchFromBranchNumber(dd.value)), `${dd.description} returns undefined`);
        }
        
        // make sure valid data returns as expected
        a.strictEqual(MoodleVersion.branchFromBranchNumber(35), '3.5', "35 converts to '3.5'");
        a.strictEqual(MoodleVersion.branchFromBranchNumber('35'), '3.5', "'35' converts to '3.5'");
    });
    
    QUnit.test('branchNumberFromBranch()', function(a){
        const mustReturnUndefined = [
            ...util.dummyDataExcept(['string'], []),
            ...util.dummyData('string', {excludeTags: ['float']}),
            util.dummyData('string.float.negative')
        ];
        a.expect(mustReturnUndefined.length + 2);
        
        // make sure the function actually exists
        a.ok(is.function(MoodleVersion.branchNumberFromBranch), 'function exists');
        
        // make sure the data that should return undefined does
        for(const dd of mustReturnUndefined){
            a.ok(is.undefined(MoodleVersion.branchNumberFromBranch(dd.value)), `${dd.description} returns undefined`);
        }
        
        // make sure that values are converted as expected
        a.strictEqual(MoodleVersion.branchNumberFromBranch('3.5'), 35, "'3.5' converts to 35");
    });
});