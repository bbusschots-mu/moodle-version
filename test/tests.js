//
//=== TEMP Utilities 'Module' ==================================================
//
// (will be separated out into an actual module when up and working)

/**
 * A dummy data definition encapsulating the piece of data itself, a
 * description, and one or more tags.
 */
class DummyData{
    
    /**
     * @param {string} desc - a description of the piece of data.
     * @param {string[]} tags - zero or more tags to associate with the data.
     * @param {*} val - the actual piece of data.
     * @param {string} [type] - the data's type
     */
    constructor(desc, tags, val, type){
        if(!(is.string(desc) && is.not.empty(desc))) throw new TypeError('description must be a non-empty string');
        if(!(is.array(tags) && is.all.string(tags))) throw new TypeError('tags must be an array of strings');
        if(is.not.undefined(type) && is.not.string(type)) throw new TypeError('if p, type must be a string');
        this._description = desc;
        this._tags = [...tags];
        this._value = val;
        this._tagLookup = {};
        this._type = type;
        for(const t of this._tags){
            this._tagLookup[t] = true;
        }
    }
    
    /*
     * @type {string}
     */
    get description(){
        return this._description;
    }
    
    /**
     * @type {string[]}
     */
    get tags(){
        return this._tags;
    }
    
    /**
     * @type {*}
     */
    get value(){
        return this._value;
    }
    
    /**
     * @type {string|undefined}
     */
    get type(){
        return this._type;
    }
    
    /**
     * @return {boolean}
     */
    hasTag(t){
        if(is.not.string(t)) throw new TypeError('tag must be a string');
        return this._tagLookup[t] ? true : false;
    }
}

/**
 * A utility 'module' for tests. Will be broken out into a separate project
 * later.
 */
const util = {
    /**
     * The library of dummy data organised by type and period-separated tag
     * path.
     *
     * This data structure is generated by the `.refreshDummyData()` function.
     * 
     * @type {Map<string, Map<string, DummyData>>}
     */
    allDummyData: {},
    refreshDummyData: function(){
        /**
         * Enter dummy data into this data structure. This will then be
         * transformed into the final output automatically
         *
         * The data structure is organised by type, and then by period-separated
         * tag-path.
         *
         * Each piece of dummy data is represented as a three-value array where
         * the first element is a string descriving the value, the second an
         * array of additional tags, and the third the value itself.
         *
         * The individual parts of the tag path and the additional tags are
         * combined to assemble the tags propert, so don't replicate tags in
         * both places
         *
         * @type {Map<string, Map<string, Array>>}
         * @private
         */
        const rawData = {
            'boolean': {
                'true': ['true', ['basic'], true],
                'false': ['false', ['falsy'], false]
            },
            'number': {
                'zero': ['the number zero', ['integer', 'falsy'], 0],
                'integer': ['a positive integer', ['basic'], 12345],
                'integer.digit': ['a single-digit number', [], 7],
                'integer.2digit': ['a 2-digit number', [], 42],
                'integer.3digit': ['a 3-digit number', [], 123],
                'integer.4digit': ['a 4-digit number', [], 1982],
                'integer.negative': ['a negative integer', [], -12345],
                'float': ['a positive floating point number', [], 3.14],
                'float.negative': ['a negative floating point number', [], -3.14]
            },
            'string': {
                'empty': ['an empty string', ['falsy'], ''],
                'word': ['a single-word string', ['basic'], 'boogers'],
                'line': ['a single-line string', [], 'boogers and snot'],
                'multiline': ['a multi-line string', [''], 'boogers\nsnot\nbogeys'],
                'zero': ['the digit 0', ['integer', 'numeric'], '0'],
                'digit': ['a single-digit number', ['integer', 'numeric'], '7'],
                'integer': ['a positive integer string', ['numeric'], '12345'],
                'integer.2digit': ['a 2-digit number', ['numeric'], '42'],
                'integer.3digit': ['a 3-digit number', ['numeric'], '123'],
                'integer.4digit': ['a 4-digit number', ['numeric'], '1982'],
                'integer.negative': ['a negative integer string', ['numeric'], '-12345'],
                'float': ['a floating point numeric string', ['numeric'], '3.14'],
                'float.negative': ['a negative floating point numeric string', ['numeric'], '-3.14']
            },
            'array': {
                'empty': ['an empty array', ['object'], []],
                'basic': ['an array of primitives', ['object', 'basic'], [true, 42, 'boogers']]
            },
            'object': {
                'null': ['null', ['empty', 'falsy', 'basic'], null],
                'empty': ['empty object', ['plain'], {}],
                'plain': ['a plain object', ['basic'], {a: 'b', c: 42, d: true}],
                'date': ['a date object', [], new Date()]
            },
            'function': {
                'void': ['a void function', ['object', 'basic'], function(){}]
            },
            'other': {
                "undefined": ['undefined', ['empty', 'falsy', 'basic'], undefined]
            }
        };
        const ans = {};
        for(const t of Object.keys(rawData)){
            ans[t] = {};
            for(const tp of Object.keys(rawData[t])){
                ans[t][tp] = new DummyData(
                    rawData[t][tp][0],
                    [...tp.split('.'), ...rawData[t][tp][1]],
                    rawData[t][tp][2],
                    t
                );
            }
        }
        this.allDummyData = ans;
    },
    
    /**
     * Returns a single piece of dummy data, or, all the dummy data for a
     * given type, or all the dummy data.
     *
     * To get a single piece of dummy data pass its type and tag path as a
     * single period-separated string, e.g. `'string.word'` for the dummy data
     * with type `string` and tag path `word`, or `'number.integer.negative'`
     * for the dummy data with type `number` and tag path `integer.negative`.
     *
     * To get all the dummy data for a given type pass the type as a string,
     * e.g. `'boolean'` for all dummy boolean data.
     *
     * To get all the dummy data, simply pass `'*'`.
     *
     * When querying all the dummy data both entire sections and specific tags
     * can be excluded, and when querying all the dummy data for a sigle type
     * specific tags can be excluded.
     *
     * @param {string} path - a type, or, a type and tag path as a single
     * period-separated string, or the special value `'*'`.
     * @param {object} [opts] - an optional options object.
     * @param {string[]} [opts.excludeTypes] - a list of types to exclude when
     * requesting all dummy data (`path` is `'*'`).
     * @param {string[]} [opts.excludeTags] - a list of tags to exclude when
     * requesting all dummy data, or the dummy data for a given type.
     * @param {string[]} [opts.excludeDefinitions] - a list of individual data
     * definitions to exclude as period-separated type and tag path strings.
     * @return {DummyData[]|DummyData|undefined} Returns all the dummy data
     * for a given type, or a single piece of dummy data for a type with tag
     * path. If only a type is passed and that type does not exist an empty
     * array is returned, if the path has two or more parts and the type or
     * tag path don't exist, `undefined` is returned.
     * @throws {TypeError}
     */
    dummyData: function(path, opts){
        if(!(is.string(path) && is.not.empty(path))) throw new TypeError('path must be a non-empty string');
        if(is.not.object(opts)) opts = {};
        const pathParts = path.split('.');
        const reqType = pathParts[0];
        
        // if a single piece of data or a single type is requested, and does not exist, return
        if(reqType !== '*'){
            if(is.not.object(this.allDummyData[reqType])) return pathParts.length === 1 ? [] : undefined;
        }
        
        // deal with requests for a single piece of data
        if(pathParts.length > 1) return this.allDummyData[reqType][pathParts.slice(1).join('.')];
        
        // deal with requests for data for one or more types
        
        // figure out what types to process
        const typesToFetch = [];
        if(reqType === '*'){
            const typeSkipLookup = {};
            if(is.array(opts.excludeTypes)){
                for(const t of opts.excludeTypes) typeSkipLookup[t] = true;
            }
            for(const t of Object.keys(this.allDummyData)){
                if(!typeSkipLookup[t]) typesToFetch.push(t);
            }
        }else{
            typesToFetch.push(reqType);
        }
        
        // figure out which individual definitions to skip
        const defSkipLookup = {};
        if(is.array(opts.excludeDefinitions)){
            for(const dp of opts.excludeDefinitions) defSkipLookup[dp] = true;
        }
        
        // process all the requested types
        const ans = [];
        const doCheckTags = is.array(opts.excludeTags);
        for(const t of typesToFetch){
            processTypeDummyData:
            for(const tp of Object.keys(this.allDummyData[t])){
                if(doCheckTags){
                    for(const et of opts.excludeTags){
                        if(this.allDummyData[t][tp].hasTag(et)) continue processTypeDummyData;
                    }
                }
                if(!defSkipLookup[`${t}.${tp}`]) ans.push(this.allDummyData[t][tp]);
            }
        }
        return ans;
    },
    
    /**
     * A function to return all dummy data except those for the given
     * types and those matching the given tags tags.
     *
     * This is a shortcut for:
     * 
     * ```
     * .dummyData(
     *     '*',
     *     {
     *         excludeTypes: arguments[0],
     *         excludeTags: arguments[1],
     *         excludeDefinitions: arguments[2]
     *     }
     * )
     * ```
     *
     * @param {string[]} [excludeTypes]
     * @param {string[]} [excludeTags]
     * @param {string[]} [excludeDefinitions]
     * @return {DummyData[]}
     */
    dummyDataExcept: function(excludeTypes, excludeTags, excludeDefinitions){
        if(is.not.array(excludeTypes)) excludeTypes = [];
        if(is.not.array(excludeTags)) excludeTags = [];
        if(is.not.array(excludeDefinitions)) excludeDefinitions = [];
        return this.dummyData('*', {excludeTypes, excludeTags, excludeDefinitions});
    },
    
    /**
     * A function to return all basic dummy data, i.e. all dummy data tagged
     * `basic`.
     *
     * This is a shortcut for `dummyDataByTag('basic')`.
     *
     * @return {DummyData[]}
     */
    dummyBasicData: function(){
        return this.dummyDataByTag('basic');
    },
    
    /**
     * A function to return all basic dummy data that's not an object, i.e. all
     * dummy data tagged `basic` that does not have either the type or tag
     * `object`.
     *
     * @return {DummyData[]}
     */
    dummyBasicPrimitives: function(){
        const ans = [];
        for(const dd of this.dummyBasicData()){
            if(dd.type != 'object' && !dd.hasTag('object')) ans.push(dd);
        }
        return ans;
    },
    
    /**
     * A function to return all basic dummy data except those for zero or more
     * given types.
     *
     * @param {...string} excludeTypes
     * @return {DummyData[]}
     */
    dummyBasicDataExcept: function(...excludeTypes){
        const excludeLookup = {};
        for(const et of excludeTypes) excludeLookup[et] = true;
        const ans = [];
        for(const dd of this.dummyBasicData()){
            if(!excludeLookup[dd.type]){
                ans.push(dd);
            }
        }
        return ans;
    },
    
    /**
     * A function to return all basic dummy primitives except those for zero or
     * more given types.
     *
     * @param {...string} excludeTypes
     * @return {DummyData[]}
     */
    dummyBasicPrimitivesExcept: function(...excludeTypes){
        const excludeLookup = {};
        for(const et of excludeTypes) excludeLookup[et] = true;
        const ans = [];
        for(const dd of this.dummyBasicPrimitives()){
            if(!excludeLookup[dd.type]){
                ans.push(dd);
            }
        }
        return ans;
    },
    
    /**
     * Returns the dummy data of one or more types.
     * 
     * @param {...string} typeList
     * @return {DummyData[]}
     * @throws {TypeError}
     */
    dummyDataByType: function(...typeList){
        if(!is.all.string(typeList)) throw new TypeError('all specified types must be strings');
        const ans = [];
        for(const t of typeList){
            if(is.object(this.allDummyData[t])) ans.push(...Object.values(this.allDummyData[t]));
        }
        return ans;
    },
    
    /**
     * Returns the dummy data matching one or more tags.
     * 
     * @param {...string} tagList
     * @return {DummyData[]}
     * @throws {TypeError}
     */
    dummyDataByTag: function(...tagList){
        if(!is.all.string(tagList)) throw new TypeError('all specified tags must be strings');
        const ans = [];
        for(const td of Object.values(this.allDummyData)){
            for(const dd of Object.values(td)){
                for(const t of tagList){
                    if(dd.hasTag(t)){
                        ans.push(dd);
                        break;
                    }
                }
            }
            
        }
        return ans;
    }
};

// initialise the dummy data
util.refreshDummyData();

//
//=== The Tests ================================================================
//

QUnit.module('Static Validation Functions', {}, function(){
    QUnit.test('isDateNumber()', function(a){
        const mustAlwaysReturnFalse = [
            ...util.dummyDataExcept([], ['integer']),
            util.dummyData('number.integer.negative'),
            util.dummyData('string.integer.negative')
            
        ];
        a.expect((mustAlwaysReturnFalse.length * 2) + 5);
        
        // make sure the function actually exists
        a.ok(is.function(MoodleVersion.isDateNumber), 'function exists');
        
        // make sure values that should always return false do so in both modes
        for(const dd of mustAlwaysReturnFalse){
            a.strictEqual(MoodleVersion.isDateNumber(dd.value, false), false, `${dd.description} returns false without strict type checking`);
            a.strictEqual(MoodleVersion.isDateNumber(dd.value, true), false, `${dd.description} returns false with strict type checking`);
        }
        
        // make sure values that are always correct return true in both modes
        a.strictEqual(MoodleVersion.isDateNumber(20180517, false), true, '20180517 returns true without strict type checking');
        a.strictEqual(MoodleVersion.isDateNumber(20180517, true), true, '20180517 returns true with strict type checking');
        
        // make sure valid strings are only accepted when strict mode is disabled
        a.strictEqual(MoodleVersion.isReleaseNumber('20180517', false), true, "'20180517' returns true without strict type checking");
        a.strictEqual(MoodleVersion.isReleaseNumber('20180517', true), false, "'20180517' returns false with strict type checking");
    });
    
    QUnit.test('isBranch()', function(a){
        const mustReturnFalse = [
            ...util.dummyDataExcept(['string'], []),
            util.dummyData('string.word'),
            util.dummyData('string.multiline'),
        ];
        a.expect(mustReturnFalse.length + 4);
        
        // make sure the function actually exists
        a.ok(is.function(MoodleVersion.isBranch), 'function exists');
        
        // make sure values that should return false do
        for(const dd of mustReturnFalse){
            a.strictEqual(MoodleVersion.isBranch(dd.value), false, `${dd.description} returns false`);
        }
        
        // make sure subtly incorrect values return false
        a.strictEqual(MoodleVersion.isBranch('0.1'), false, "'0.1' returns false");
        a.strictEqual(MoodleVersion.isBranch('3.55'), false, "'3.55' returns false");
        
        // make sure valid values return true
        a.strictEqual(MoodleVersion.isBranch('3.5'), true, "'3.5' returns true");
    });
    
    QUnit.test('isBranchNumber()', function(a){
        const mustAlwaysReturnFalse = [
            ...util.dummyDataExcept([], ['2digit'])
        ];
        a.expect((mustAlwaysReturnFalse.length * 2) + 5);
        
        // make sure the function actually exists
        a.ok(is.function(MoodleVersion.isBranchNumber), 'function exists');
        
        // make sure values that should always return false do so in both modes
        for(const dd of mustAlwaysReturnFalse){
            a.strictEqual(MoodleVersion.isBranchNumber(dd.value, false), false, `${dd.description} returns false without strict type checking`);
            a.strictEqual(MoodleVersion.isBranchNumber(dd.value, true), false, `${dd.description} returns false with strict type checking`);
        }
        
        // make sure values that are always correct return true in both modes
        a.strictEqual(MoodleVersion.isBranchNumber(35, false), true, '35 returns true without strict type checking');
        a.strictEqual(MoodleVersion.isBranchNumber(35, true), true, '35 returns true with strict type checking');
        
        // make sure valid strings are only accepted when strict mode is disabled
        a.strictEqual(MoodleVersion.isBranchNumber('35', false), true, "'35' returns true without strict type checking");
        a.strictEqual(MoodleVersion.isBranchNumber('35', true), false, "'35' returns false with strict type checking");
    });
    
    QUnit.test('isReleaseNumber()', function(a){
        const mustAlwaysReturnFalse = [
            ...util.dummyDataExcept([], ['integer'], ['string.empty']),
            util.dummyData('number.integer.negative'),
            util.dummyData('string.integer.negative')
            
        ];
        a.expect((mustAlwaysReturnFalse.length * 2) + 11);
        
        // make sure the function actually exists
        a.ok(is.function(MoodleVersion.isReleaseNumber), 'function exists');
        
        // make sure values that should always return false do so in both modes
        for(const dd of mustAlwaysReturnFalse){
            a.strictEqual(MoodleVersion.isReleaseNumber(dd.value, false), false, `${dd.description} returns false without strict type checking`);
            a.strictEqual(MoodleVersion.isReleaseNumber(dd.value, true), false, `${dd.description} returns false with strict type checking`);
        }
        
        // make sure values that are always correct return true in both modes
        a.strictEqual(MoodleVersion.isReleaseNumber(0, false), true, '0 returns true without strict type checking');
        a.strictEqual(MoodleVersion.isReleaseNumber(0, true), true, '0 returns true with strict type checking');
        a.strictEqual(MoodleVersion.isReleaseNumber(3, false), true, '3 returns true without strict type checking');
        a.strictEqual(MoodleVersion.isReleaseNumber(3, true), true, '3 returns true with strict type checking');
        a.strictEqual(MoodleVersion.isReleaseNumber(33, false), true, '33 returns true without strict type checking');
        a.strictEqual(MoodleVersion.isReleaseNumber(33, true), true, '33 returns true with strict type checking');
        
        // make sure valid strings are only accepted when strict mode is disabled
        a.strictEqual(MoodleVersion.isReleaseNumber('3', false), true, "'3' returns true without strict type checking");
        a.strictEqual(MoodleVersion.isReleaseNumber('3', true), false, "'3' returns false with strict type checking");
        
        // make sure both the digit zero and the empty string are accepted when strict mode is disabled
        a.strictEqual(MoodleVersion.isReleaseNumber('0', false), true, "'0' returns true without strict type checking");
        a.strictEqual(MoodleVersion.isReleaseNumber('', false), true, "the empty string returns true without strict type checking");
    });
    
    QUnit.test('isReleaseType()', function(a){
        const mustReturnFalse = [
            ...util.dummyBasicData()
        ];
        
        a.expect(mustReturnFalse.length + 4);
        
        // make sure the function actually exists
        a.ok(is.function(MoodleVersion.isReleaseType), 'function exists');
        
        // make sure values that should return false do
        for(const dd of mustReturnFalse){
            a.strictEqual(MoodleVersion.isReleaseType(dd.value), false, `${dd.description} returns false`);
        }
        
        // make sure all three valid values return true
        a.strictEqual(MoodleVersion.isReleaseType('development'), true, "'development' returns true");
        a.strictEqual(MoodleVersion.isReleaseType('official'), true, "'official' returns true");
        a.strictEqual(MoodleVersion.isReleaseType('weekly'), true, "'weekly' returns true");
    });
    
    QUnit.test('isReleaseSuffix()', function(a){
        const mustReturnFalse = [
            ...util.dummyBasicData()
        ];
        
        a.expect(mustReturnFalse.length + 4);
        
        // make sure the function actually exists
        a.ok(is.function(MoodleVersion.isReleaseSuffix), 'function exists');
        
        // make sure values that should return false do
        for(const dd of mustReturnFalse){
            a.strictEqual(MoodleVersion.isReleaseSuffix(dd.value), false, `${dd.description} returns false`);
        }
        
        // make sure all three valid values return true
        a.strictEqual(MoodleVersion.isReleaseSuffix('dev'), true, "'dev' returns true");
        a.strictEqual(MoodleVersion.isReleaseSuffix(''), true, 'an empty string returns true');
        a.strictEqual(MoodleVersion.isReleaseSuffix('+'), true, "'+' returns true");
    });
});

QUnit.module('Static Conversion Functions', {}, function(){    
    QUnit.test('branchFromBranchNumber()', function(a){
        const mustReturnUndefined = [
            ...util.dummyDataExcept([], ['2digit'])
        ];
        a.expect(mustReturnUndefined.length + 3);
        
        // make sure the function actually exists
        a.ok(is.function(MoodleVersion.branchFromBranchNumber), 'function exists');
        
        // make sure the data that should return undefined does
        for(const dd of mustReturnUndefined){
            a.ok(is.undefined(MoodleVersion.branchFromBranchNumber(dd.value)), `${dd.description} returns undefined`);
        }
        
        // make sure valid data returns as expected
        a.strictEqual(MoodleVersion.branchFromBranchNumber(35), '3.5', "35 converts to '3.5'");
        a.strictEqual(MoodleVersion.branchFromBranchNumber('35'), '3.5', "'35' converts to '3.5'");
    });
    
    QUnit.test('branchFromBranchingDateNumber()', function(a){
        const mustReturnUndefined = [
            ...util.dummyBasicDataExcept('number')
        ];
        a.expect(mustReturnUndefined.length + 5);
        
        // make sure the function actually exists
        a.ok(is.function(MoodleVersion.branchFromBranchingDateNumber), 'function exists');
        
        // make sure the data that should return undefined does
        for(const dd of mustReturnUndefined){
            a.ok(is.undefined(MoodleVersion.branchFromBranchingDateNumber(dd.value)), `${dd.description} returns undefined`);
        }
        
        // make sure valid data returns as expected
        a.strictEqual(MoodleVersion.branchFromBranchingDateNumber(20180517), '3.5', "20180517 converts to '3.5'");
        a.strictEqual(MoodleVersion.branchFromBranchingDateNumber('20180517'), '3.5', "'20180517' converts to '3.5'");
        a.ok(is.undefined(MoodleVersion.branchFromBranchingDateNumber(20180513)), '20180513 converts to undefined (no such mapping)');
        a.ok(is.undefined(MoodleVersion.branchFromBranchingDateNumber('20180513')),"'20180513' converts to undefined (no such mapping)");
    });
    
    QUnit.test('branchNumberFromBranch()', function(a){
        const mustReturnUndefined = [
            ...util.dummyDataExcept(['string'], []),
            ...util.dummyData('string', {excludeTags: ['float']}),
            util.dummyData('string.float.negative')
        ];
        a.expect(mustReturnUndefined.length + 2);
        
        // make sure the function actually exists
        a.ok(is.function(MoodleVersion.branchNumberFromBranch), 'function exists');
        
        // make sure the data that should return undefined does
        for(const dd of mustReturnUndefined){
            a.ok(is.undefined(MoodleVersion.branchNumberFromBranch(dd.value)), `${dd.description} returns undefined`);
        }
        
        // make sure that values are converted as expected
        a.strictEqual(MoodleVersion.branchNumberFromBranch('3.5'), 35, "'3.5' converts to 35");
    });
    
    QUnit.test('branchNumberFromBranchingDateNumber()', function(a){
        const mustReturnUndefined = [
            ...util.dummyBasicDataExcept('number')
        ];
        a.expect(mustReturnUndefined.length + 5);
        
        // make sure the function actually exists
        a.ok(is.function(MoodleVersion.branchNumberFromBranchingDateNumber), 'function exists');
        
        // make sure the data that should return undefined does
        for(const dd of mustReturnUndefined){
            a.ok(is.undefined(MoodleVersion.branchNumberFromBranchingDateNumber(dd.value)), `${dd.description} returns undefined`);
        }
        
        // make sure valid data returns as expected
        a.strictEqual(MoodleVersion.branchNumberFromBranchingDateNumber(20180517), 35, '20180517 converts to 35');
        a.strictEqual(MoodleVersion.branchNumberFromBranchingDateNumber('20180517'), 35, "'20180517' converts to 35");
        a.ok(is.undefined(MoodleVersion.branchNumberFromBranchingDateNumber(20180513)), '20180513 converts to undefined (no such mapping)');
        a.ok(is.undefined(MoodleVersion.branchNumberFromBranchingDateNumber('20180513')),"'20180513' converts to undefined (no such mapping)");
    });
    
    QUnit.test('branchingDateNumberFromBranch()', function(a){
        const mustReturnUndefined = [
            ...util.dummyBasicDataExcept('string')
        ];
        a.expect(mustReturnUndefined.length + 3);
        
        // make sure the function actually exists
        a.ok(is.function(MoodleVersion.branchingDateNumberFromBranch), 'function exists');
        
        // make sure the data that should return undefined does
        for(const dd of mustReturnUndefined){
            a.ok(is.undefined(MoodleVersion.branchingDateNumberFromBranch(dd.value)), `${dd.description} returns undefined`);
        }
        
        // make sure valid data returns as expected
        a.strictEqual(MoodleVersion.branchingDateNumberFromBranch('3.5'), 20180517, "'3.5' converts to 20180517");
        a.ok(is.undefined(MoodleVersion.branchingDateNumberFromBranch('9.9')), "'9.9' converts to undefined (no such mapping)");
    });
    
    QUnit.test('branchingDateNumberFromBranchNumber()', function(a){
        const mustReturnUndefined = [
            ...util.dummyBasicDataExcept('number')
        ];
        a.expect(mustReturnUndefined.length + 5);
        
        // make sure the function actually exists
        a.ok(is.function(MoodleVersion.branchingDateNumberFromBranchNumber), 'function exists');
        
        // make sure the data that should return undefined does
        for(const dd of mustReturnUndefined){
            a.ok(is.undefined(MoodleVersion.branchingDateNumberFromBranchNumber(dd.value)), `${dd.description} returns undefined`);
        }
        
        // make sure valid data returns as expected
        a.strictEqual(MoodleVersion.branchingDateNumberFromBranchNumber(35), 20180517, '35 converts to 20180517');
        a.strictEqual(MoodleVersion.branchingDateNumberFromBranchNumber('35'), 20180517, "'35' converts to 20180517");
        a.ok(is.undefined(MoodleVersion.branchingDateNumberFromBranchNumber(99)), '99 converts to undefined (no such mapping)');
        a.ok(is.undefined(MoodleVersion.branchingDateNumberFromBranchNumber('99')),"'99' converts to undefined (no such mapping)");
    });
    
    QUnit.test('dateFromDateNumber()', function(a){
        const mustThrow = [
            ...util.dummyDataExcept(['number'], ['integer']),
            util.dummyData('number.integer.4digit'),
            util.dummyData('string.integer.4digit')
        ];
        a.expect(mustThrow.length + 3);
        
        // make sure the function actually exists
        a.ok(is.function(MoodleVersion.dateFromDateNumber), 'function exists');
        
        // make sure all values that should throw an error do
        for(const dd of mustThrow){
            a.throws(
                ()=>{ MoodleVersion.dateFromDateNumber(dd.value); },
                TypeError,
                `${dd.description} throws a type error`
            );
        }
        
        // make sure valid values are converted as expected
        let d = new Date('2018-05-01T00:00:00.000Z');
        a.strictEqual(MoodleVersion.dateFromDateNumber(20180501).toISOString(), d.toISOString(), '20180501 converts correctly');
        d = new Date('2018-12-25T00:00:00.000Z');
        a.strictEqual(MoodleVersion.dateFromDateNumber(20181225).toISOString(), d.toISOString(), '20181225 converts correctly');
    });
    
    QUnit.test('dateNumberFromDate()', function(a){
        const mustThrow = [
            ...util.dummyDataExcept([], [], ['object.date'])
        ];
        a.expect(mustThrow.length + 3);
        
        // make sure the function actually exists
        a.ok(is.function(MoodleVersion.dateNumberFromDate), 'function exists');
        
        // make sure all values that should throw an error do
        for(const dd of mustThrow){
            a.throws(
                ()=>{ MoodleVersion.dateNumberFromDate(dd.value); },
                TypeError,
                `${dd.description} throws a type error`
            );
        }
        
        // make sure valid values are converted as expected
        a.strictEqual(MoodleVersion.dateNumberFromDate(new Date('2018-05-01T00:00:00.000Z')), 20180501, '2018-05-01T00:00:00.000Z converts to 20180501');
        a.strictEqual(MoodleVersion.dateNumberFromDate(new Date('2018-12-25T00:00:00.000Z')), 20181225, '2018-12-25T00:00:00.000Z converts to 20181225');
    });
    
    QUnit.test('releaseSuffixFromReleaseType()', function(a){
        const mustReturnUndefined = [
            ...util.dummyBasicData()
        ];
        a.expect(mustReturnUndefined.length + 7);
        
        // make sure the function actually exists
        a.ok(is.function(MoodleVersion.releaseSuffixFromReleaseType), 'function exists');
        
        // make sure that values that should return undefined do
        for(const dd of mustReturnUndefined){
            a.ok(is.undefined(MoodleVersion.releaseSuffixFromReleaseType(dd.value)), `${dd.description} returns undefined`);
        }
        
        // make sure the three valid values convert correctly, regardless of case
        a.strictEqual(MoodleVersion.releaseSuffixFromReleaseType('development'), 'dev', "'development' converts to 'dev'");
        a.strictEqual(MoodleVersion.releaseSuffixFromReleaseType('DEVELOPMENT'), 'dev', "'DEVELOPMENT' converts to 'dev'");
        a.strictEqual(MoodleVersion.releaseSuffixFromReleaseType('official'), '', "'official' converts to ''");
        a.strictEqual(MoodleVersion.releaseSuffixFromReleaseType('OFFICIAL'), '', "'OFFICIAL' converts to ''");
        a.strictEqual(MoodleVersion.releaseSuffixFromReleaseType('weekly'), '+', "'weekly' converts to '+'");
        a.strictEqual(MoodleVersion.releaseSuffixFromReleaseType('WEEKLY'), '+', "'WEEKLY' converts to '+'");
    });
    
    QUnit.test('releaseTypeFromReleaseSuffix()', function(a){
        const mustReturnUndefined = [
            ...util.dummyBasicData()
        ];
        a.expect(mustReturnUndefined.length + 5);
        
        // make sure the function actually exists
        a.ok(is.function(MoodleVersion.releaseTypeFromReleaseSuffix), 'function exists');
        
        // make sure that values that should return undefined do
        for(const dd of mustReturnUndefined){
            a.ok(is.undefined(MoodleVersion.releaseTypeFromReleaseSuffix(dd.value)), `${dd.description} returns undefined`);
        }
        
        // make sure the three valid values convert correctly, regardless of case
        a.strictEqual(MoodleVersion.releaseTypeFromReleaseSuffix('dev'), 'development', "'dev' converts to 'development'");
        a.strictEqual(MoodleVersion.releaseTypeFromReleaseSuffix('DEV'), 'development', "'DEV' converts to 'development'");
        a.strictEqual(MoodleVersion.releaseTypeFromReleaseSuffix(''), 'official', "'' converts to 'official'");
        a.strictEqual(MoodleVersion.releaseTypeFromReleaseSuffix('+'), 'weekly', "'+' converts to 'weekly'");
    });
});

QUnit.module('Object Utility Functions', function(){
    QUnit.test('.clone()', function(a){
        const propertiesToTest = ['_branchNumber', '_branchingDateNumber', '_releaseNumber', '_releaseType', '_buildNumber'];
        a.expect((propertiesToTest.length * 3) + 3);
        
        // make sure the function actually exists
        a.ok(is.function(MoodleVersion.prototype.clone), 'function exists');
        
        // make sure the clone really is a clone object
        let v = new MoodleVersion();
        let vc = v.clone();
        a.ok(vc instanceof MoodleVersion, 'clone is a MoodleVersion object');
        a.notStrictEqual(v, vc, 'the clone is not a reference to the original');
        
        // make sure all values get coppied when undefined
        for(const p of propertiesToTest){
            a.strictEqual(v[p], vc[p], `property ${p} coppied correctly when undefined`);
        }
        
        // make sure all values get coppied with a known version
        v = MoodleVersion.fromObject({
            branchNumber: 35,
            releaseNumber: 0,
            releaseType: 'weekly',
            buildNumber: 20180614
        });
        vc = v.clone();
        for(const p of propertiesToTest){
            a.strictEqual(v[p], vc[p], `property ${p} coppied correctly on known version`);
        }
        
        // make sure all values get coppied with an unknown version
        v = MoodleVersion.fromObject({
            branchNumber: 36,
            branchindDateNumber: 20180517,
            releaseNumber: 0,
            releaseType: 'development',
            buildNumber: 20180524
        });
        vc = v.clone();
        for(const p of propertiesToTest){
            a.strictEqual(v[p], vc[p], `property ${p} coppied correctly on an unknown version`);
        }
    });
    
    QUnit.only('.toString()', function(a){
        a.expect(6);
        
        // make sure the function actually exists
        a.ok(is.function(MoodleVersion.prototype.toString), 'function exists');
        
        // make sure the function returns a string
        let v = new MoodleVersion();
        a.ok(is.string(v.toString()), 'returns a string');
        
        // make sure the function can handle an empty object
        a.strictEqual(v.toString(), '??.??.?? (type: ??, branching date: ?? & build: ??)', 'empty object rendered correctly');
        
        // make sure the function correctly includes all data
        v = MoodleVersion.fromObject({
            branchNumber: 35,
            releaseNumber: 0,
            releaseType: 'official',
            buildNumber: 20180614
        });
        a.strictEqual(v.toString(), '3.5.0 (type: official, branching date: 20180517 & build: 20180614)', 'complete version rendered correctly');
        
        // make sure the function correctly handles the suffixes
        v.releaseType = 'development';
        a.strictEqual(v.toString(), '3.5.0dev (type: development, branching date: 20180517 & build: 20180614)', 'dev version rendered correctly');
        v.releaseType = 'weekly';
        a.strictEqual(v.toString(), '3.5.0+ (type: weekly, branching date: 20180517 & build: 20180614)', 'weekly version rendered correctly');
    });
});

QUnit.module('factory methods', function(){
    QUnit.test('fromObject()', function(a){
        const mustThrow = [
            ...util.dummyBasicPrimitives()
        ];
        const props = ['_branchNumber', '_branchingDateNumber', '_releaseNumber', '_releaseType', '_buildNumber'];
        a.expect(mustThrow.length + (props.length * 3) + 5);
        
        // make sure the function actually exists
        a.ok(is.function(MoodleVersion.fromObject), 'function exists');
        
        // make sure data that should throw an error does
        for(const dd of mustThrow){
            a.throws(
                ()=>{ MoodleVersion.fromObject(dd.value); },
                TypeError,
                `${dd.description} throws a type error`
            );
        }
        
        // make sure an empty object is treated correctly
        let v = MoodleVersion.fromObject({});
        for(const p of props){
            a.ok(is.undefined(v[p]), `${p} undefined when passed empty object`);
        }
        
        // a helper function to quickly check all properties against an array of values
        checkAllProps = (msg, ...vals)=>{
            for(let i = 0; i < props.length; i++){
                a.strictEqual(v[props[i]], vals[i], `${props[i]} ${msg}`);
            }
        };
        
        // make sure all properties get saved when given the natively stored data for a valid branch
        // this test covers auto-fill of branching dates
        v = MoodleVersion.fromObject({
            branchNumber: 33,
            releaseNumber: 6,
            releaseType: 'official',
            buildNumber: 20180517
        });
        checkAllProps('correctly saved when passed native data for valid branch', 33, 20170515, 6, 'official', 20180517);
        
        // make sure all properties get saved when given auto-translated data for a valid branch
        v = MoodleVersion.fromObject({
            branch: '3.3',
            releaseNumber: 6,
            releaseSuffix: '',
            buildNumber: 20180517
        });
        checkAllProps('correctly saved when passed data that needs transforming for valid branch', 33, 20170515, 6, 'official', 20180517);
        
        // make sure branches auto-fill to branching dates
        v = MoodleVersion.fromObject({
            branchingDateNumber: 20170515,
            releaseNumber: 6,
            releaseSuffix: '',
            buildNumber: 20180517
        });
        a.strictEqual(v._branchNumber, 33, 'Branch correctly auto-filled from brancing date number');
        v = MoodleVersion.fromObject({
            branchingDate: new Date('2017-05-15T00:00:00.000Z'),
            releaseNumber: 6,
            releaseSuffix: '',
            buildNumber: 20180517
        });
        a.strictEqual(v._branchNumber, 33, 'Branch correctly auto-filled from brancing date');
        
        // make sure un-known branches can be created
        v = MoodleVersion.fromObject({
            branchNumber: 36,
            branchingDateNumber: 20180615,
            releaseNumber: 0,
            releaseSuffix: 'dev',
            buildNumber: 20180618
        });
        a.strictEqual(v._branchNumber, 36, 'un-known branch successfully saved');
        a.strictEqual(v._branchingDateNumber, 20180615, 'un-known branching date successfully saved');
    });
});